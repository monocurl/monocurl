/* CATEGORY[0]: Important Scene Variables */

/* ABSTRACT: The camera variable is one of three important scene state variables. The camera dictates how the scene is being viewed at any given point. You should only assign the @REF[Camera] functor to the camera variable. As with all scene variables, you should only modify the camera using animations (apart from the config slide), so instead of using `camera = ...`, use something such as @REF[Set]. In fact, we can even use animations such as @REF[CameraLerp] to make smooth camera transitions */
/* IMPORTANT: While a camera may be helpful in 2D, a camera is absolutely critical in 3D so if you are doing 3D scenes then the camera is something you want to absolutely experiment with. Even in 2D, I think its still beneficial to zoom or pan in on particular sections of the scene for example. */
tree camera = {0.1, 10, {0, 1, 0}, {0, 0, 4}, {0, 0, -1}}

/* ABSTRACT: The play variable is one of three important scene state variables. Every single slide (apart from the config slide), the play variable is reset. During the initialization of a slide, your job is to add animations to the play variable. After initialization, all animations in the play variable are run, and then the process continues on the next slide. We recommend you check out the blogs on animations for more information on the play variable. */
/* IMPORTANT: The play variable is perhaps the most important variable in all of Monocurl when it comes to slideshows and videos. Make sure you are aware of the exact semantics behind it. It may be confusing at first, but understanding it properly is the key to composing complex animations. */
var p = {}

/* ABSTRACT: The background variable is one of three important scene state variables. The background should be a 4-vector that dictates the color of the background of the screen. Like the camera variable, you should not modify it during slide initialization (with exception to the config slide), and instead use animations such as @REF[Set] or @REF[Lerp]. By default, the background is fully black, although I personally think Monocurl looks better in a light theme.  */
/* REMARK: In the majority of cases, I find it better to have the background be constant throughout the scene, and if we really need a changing background to do so via a rectangle that changes color or something similar. The reasons are somewhat personal, but I feel the background should set the theme of the scene, and it doesn't make all that much sense to change the theme in the middle. Nevertheless, this option exists. */ 
/* IMPORTANT: The background variable is definitely important, and even though it is simple, you should probably memorize its function. */
tree background = {0, 0, 0, 1}

/* CATEGORY[19]: Animation Utilities */

/* ABSTRACT: This function returns the element it is given */
/* IMPORTANT: This function is utilized heavily as a functor so that we can use sub expressions when defining certain functions (i.e. create functions that would not otherwise fit on a single line). In some sense, it also allows us to create scoped blocks present in other languages. */
/* PARAMETER[element]: the element that will be passed through */
/* RETURN: the element that was passed in */
func identity(element) = element

/* ABSTRACT: Linearly interpolates between two given values. In particular, we define lerp somewhat recursively. If we are interpolating between two numbers, then the interpolated value is calculated as `(1-t) * a + t * b`. Otherwise, suppose we are interpolating between two vectors. Then, the resultant value is defined to be the recurisively lerped value of each of the individual entries. In particular, both vectors must be of the same length. Then, suppose both a and b are functors. We say two functors match if they were spawned by the same function (in practice, if you give two functors who were spawned by different functions but whose argument labels are all identical, lerp will still probably succeed, but for simplicity we present it as the preceeding definition). If a and b match acording to our definition, then we are able to lerp between a and b by lerping on the individual subfields. Finally, suppose that a is a functor wrapping a vector and b is a vector (or vice versa), then we will interpolate as if we had two vectors. Likewise if we have a functor wrapping a number and the other field being a number. If none of the following criteria are met, then an error will be thrown. In particular, if at any point lerp encounters a map, two vectors of differing lengths, or a character (typically from a string), then an error will be thrown. */
/* REMARK: An important consideration is that when interpolating between two functors, lerp will skip any values that are equal (in fact, when lerping anything it will skip it if they're equal, but the biggest conseuquence is when we are lerping functors). This might not appear to be a big deal, but it is actually important because now we can lerp between two functors that have a string as one of their arguments, so long as that particular argument is equal for both functors. Had we done a naive interpolation on the equal values, we would receive an error because we wouldn't be able to lerp between the strings, even though they aer equal. Thus, you are free to lerp functors that have arguments that are not lerpable, so long as they are equal in both functors. */
/* IMPORTANT: Interpolation is one of the cornerstones of Monocurl, and to master Monocurl is to master interpolation. While you might not use this function directly, you might use the @REF[Lerp] animation a lot, and the semantics of that animation are precisely the same as this function. Therefore, it is important to know the semantics of how lerp behaves. */
/* PARAMETER[a]: the starting value to interpolate */
/* PARAMETER[b]: the ending value to interpolate */
/* PARAMETER[t]: the amount we should bias towards b in the interpolation. Expected to be in the closed interval [0,1] (though as of this writing, this is not actually enforced and one is free to go outside this interval, in which case extrapolation is done) */
/* RETURN: the interpolated value according to the above procedure */
func lerp(a, b, t) = native lerp(a, b, t)

/* ABSTRACT: To avoid having to write many redundant lerps, we can use a keyframe lerp that essentially allows interpolation with many intermediate states. In particular, we can say what the output should be at sseveral key times using a map from times to values, and then a basic linear interpolation is used in the intermediate areas. In contrast to @REF[lerp], if a value of t is provided outside the range of keyframes, then either the lowest or highest keyframe is used. Also, to see what sort of inputs are allowed to be inputted, see the write-up in @REF[lerp]. */
/* REMARK: Maps in Monocurl are guaranteed to be traversed in insertion order. Moreover, if we declare a dictionary literal such as `{0: ..., 1: ..., 4:....}`, then the keys are said to be inserted in the order `0, 1, 4`. When providing the keyframes to keyframe_lerp, you should insure that the insertion order of the keyframes is the order you want them to be processed in (in other words, make sure that you do not write something such as  `{2:..., 1:....}` because then the insertion order has descending keys). */
/* IMPORTANT: This function is one of the easiest ways to create color gradients by hand. The semantics of this function are also similar to that of @REF[Keyframe]. */
/* PARAMETER[keyframes]: a map from time to values. It is (currently) your duty to ensure that the order of keys in the map is increasing order, but this is pretty easy to do if we use a map literal */
/* PARAMETER[t]: how far along to go in the interpolation process. A value of t that is below the minimum specified in the keyframes will result in the output being the value associated with the minimum such time, and similarly for values of t that exceed the maximum. Otherwise, a linear interpolation of the keyframes that the value of t is sandwiched between is output */
/* RETURN: the keyframe interpolated value as specified by the above procedure */
func keyframe_lerp(keyframes, t) = native keyframe_lerp(keyframes, identity!, t)

/* ABSTRACT: The linear function is relatively useless, but exists to semantically identify when you want a rate function that is the identity */
/* PARAMETER[t]: the input value */
/* RETURN: whatever value was inputted */
func linear(t) = t

/* ABSTRACT: A continous function that is monotonically non-decreasing on the interval [0,1], and is surjective onto [0,1] (with the domain again being [0,1]). Moreover, it has a small derivative when t is around 0 or 1. This means that as a rate function, an observer appears a slow startup, a quick middle, and a slow end. The function likely wont throw errors if a value outside of [0,1] is provided, but the exact output is undefined. */
/* PARAMETER[t]: the input value */
/* RETURN: a smooth function applied to the input */
func smooth(t) = native smooth(t)

/* ABSTRACT: A continous function that is monotonically non-decreasing on the interval [0,1], and is surjective onto [0,1] (with the domain again being [0,1]). Moreover, it has a small derivative when t is around 0. This means that as a rate function, an observer appears a slow start and quick finish. The function likely wont throw errors if a value outside of [0,1] is provided, but the exact output is undefined. */
/* PARAMETER[t]: the input value */
/* RETURN: a smooth_in function applied to the input */
func smooth_in(t) = native smooth_in(t)

/* ABSTRACT: A continous function that is monotonically non-decreasing on the interval [0,1], and is surjective onto [0,1] (with the domain again being [0,1]). Moreover, it has a small derivative when t is around 1. This means that as a rate function, an observer appears a quick  start and slow finish. The function likely wont throw errors if a value outside of [0,1] is provided, but the exact output is undefined. */
/* PARAMETER[t]: the input value */
/* RETURN: a smooth_out function applied to the input */
func smooth_out(t) = native smooth_out(t)

/* ABSTRACT: Given a reference vector, perform an action on all of the individual references (e.g. the leafs) */
/* PARAMETER[vars&]: the reference vector */
/* PARAMETER[action(leaf&)]: the action to take on individual references */
/* RETURN: A vector containing the responses for every single action */
func reference_map(vars&, action(leaf&)) = native reference_map(vars, action!)

/* CATEGORY[20]: Colors */

/* ABSTRACT: A red color with full opacity */
let RED			= {0.9, 0.3, 0.2, 1}
/* ABSTRACT: An orange color with full opacity */
let ORANGE		= {1.0, 0.7, 0.2, 1}
/* ABSTRACT: A bright yellow color with full opacity */
let YELLOW		= {1.0, 1.0, 0.0, 1}
/* ABSTRACT: A green color with full opacity */
let GREEN		= {0.2, 0.6, 0.3, 1}
/* ABSTRACT: A blue color with full opacity */
let BLUE		= {0.1, 0.4, 0.6, 1}
/* ABSTRACT: A purple color with full opacity */
let PURPLE		= {0.6, 0.4, 0.7, 1}
/* ABSTRACT: A bright white color with full opacity */
let WHITE		= {1.0, 1.0, 1.0, 1}
/* ABSTRACT: A fully clear color, with all four RGBA channels set to 0 */
let CLEAR		= {0.0, 0.0, 0.0, 0}
/* ABSTRACT: A light gray color with full opacity */
let LIGHT_GRAY  = {0.7, 0.7, 0.7, 1}
/* ABSTRACT: A gray color with full opacity */
let GRAY		= {0.5, 0.5, 0.5, 1}
/* ABSTRACT: A dark gray color with full opacity */
let DARK_GRAY   = {0.3, 0.3, 0.3, 1}
/* ABSTRACT: A fully black color with full opacity */
let BLACK		= {0.0, 0.0, 0.0, 1}

/* CATEGORY[17]: Container Utilities */

/* ABSTRACT: Sorts a given vector */
/* PARAMETER[v]: the vector to sort */
/* RETURN: the sorted vector */
func sort(v) = native sort(v)


/* ABSTRACT: Left keys the given vector */
/* REMARK: This function is similar to "enumerate" in many languages. It is useful when iterating over a collection and you need to know the index. In some cases, it may also be useful for tagging purposes. */
/* PARAMETER[v]: the vector to left key */
/* RETURN: a vector of the same length as the input, but each element x in the input vector is replaced by a vector of two elements, where the first element of the sub vector is the index of x, and the second element of the sub vector is x. */
func left_key(v) = native left_key(v)

/* ABSTRACT: Right keys the given vector */
/* IMPORTANT: This function is important enough to memorize. In particular, we recommend you read the remark about recovering permutations from a sort */
/* REMARK: Like @REF[left_key], this function is helpful when we need the index of an element while iterating. However, this function also can be used when we want to @REF[sort] a vector and then recover the permutation that the sort induced. In particular, if we call `sort(right_key(v))`, then the sequence of first subelements of each element in the resultant vector will be the same as `sort(v)`, and the sequence of second subelements of each element in the resultant vector gives the permutation that the sort applied. Note that if we had used @REF[left_key] instead, nothing would happen as in that case, the sequence of first subelements of each element is already sorted.*/
/* PARAMETER[v]: the vector to right key */
/* RETURN: a vector of the same length as the input, but each element x in the input vector is replaced by a vector of two elements, where the first element of the sub vector is the index of x, and the second element of the sub vector is x. */
func right_key(v) = native right_key(v)

/* ABSTRACT: Reverse the given vector */
/* PARAMETER[v]: the vector to reverse */
/* RETURN: a vector of the same length as the input, but the order of elements are now reversed */
func reverse(v) = native reverse(v)

/* ABSTRACT: Zips the two given vector */
/* PARAMETER[u]: the first vector to zip */
/* PARAMETER[v]: the second vector to zip. `u` and `v` are expected to be of the same length */
/* RETURN: a vector of the same length as `u` and `v`, but the `i`th element of the returned vector is `{u[i], v[i]}` */
func zip(u, v) = native zip(u, v)


/* ABSTRACT: Applies a function to each element in the input vector */
/* PARAMETER[v]: the vector to which we want to apply the function to */
/* PARAMETER[f(x)]: the function take takes in an element of `v` and spits out the mapped value */
/* RETURN: a vector of the same length as `v`, but each element x in `v` is replaced with `f(x)` */
func map(v, f(x)) = native map(v, f!)

/* ABSTRACT: Applies a binary operator repeatedly to a vector. We define the behavior recurisely. If the input vector is of zero length, then the seed value is returned. Otherwise, we first calculate the reduced value on the prefix of the input vector that contains all but the last element. Label that value `x` and the last element of `v` will be labelled `y` (the element we excluded in the recursive call). The returned value of the function is then the value of `binary(x, y)`. */
/* REMARK: Generally, I find the syntax of this function to be a bit clunky in Monocurl and in many cases it is generally easier to just write a for loop that does the same thing when necessary. The function is still provided in the standard library regardless. */
/* PARAMETER[v]: the vector that will supply the argument y for the binary operator */
/* PARAMETER[seed]: the seed that will be used to start the reduction process */
/* PARAMETER[binary(x,y)]: the binary operator */
/* RETURN: the value calculated according to the process specified above */
func reduce(v, seed, binary(x, y)) = native reduce(v, seed, binary!)

/* ABSTRACT: Gives the length of the given vector or map */
/* IMPORTANT: This function is common enough to memorize */
/* PARAMETER[v]: the vector or map of which we want to find the length */
/* RETURN: the length of the vector or the map */
func len(v) = native len(v)

/* ABSTRACT: Returns the depth of the given element. We define the depth recursively. If an element is not a vector, its depth is said to be zero. Otherwise if the element is a vector, its depth is said to be 1 more than the maximum depth of all its elements. The empty vector is said to have depth 1. */
/* PARAMETER[v]: the element we want to take the depth of. Note that it need not be a vector, in which case the returned value is 0 */
/* RETURN: the depth of the given element as specified above */
func depth(v) = native depth(v)

/* ABSTRACT: counts the amount of elements in a vector that satisfy a given predicate */
/* PARAMETER[v]: the vector that gives the list of elements of which the predicate will be applied to */
/* PARAMETER[predicate(x)]: the user-provided predicate function, which should return 0 if the given element should not included in the total tally, and any other number otherwise */
/* RETURN: the amount of elements that matched the predicate. For an empty vector, the count will always be zero */
func count(v, predicate(x)) = native count(v, predicate!)

/* ABSTRACT: Given a vector, we spit out the subset of elements that matched the predicate. In particular, order is preserved across this transformation so that the returned vector is a subsequence of the input. */
/* PARAMETER[v]: the vector that provides the elements that we want to filter */
/* PARAMETER[predicate(x)]: the predicate function that specifies which elements of the input vector should be kept in the output vector. The predicate should return 0 if the element should not be included, and any other number if it should be included. */
/* RETURN: a vector that is a subsequence of the input, and only contains the elements of the input vector that matched the predicated function */
func filter(v, predicate(x)) = native filter(v, predicate!)

/* ABSTRACT: Calculates the sum of the entries of a vector */
/* PARAMETER[v]: a vector of a numbers */
/* RETURN: The sum of all entries of the given vector. If `v` is empty, this function returns 0 */
func sum(v) = native sum(v)

/* ABSTRACT: Calculates the product of the entries of a vector */
/* PARAMETER[v]: a vector of a numbers */
/* RETURN: The product of all entries of the given vector. If `v` is empty, this function returns 1 */
func product(v) = native product(v))

/* ABSTRACT: Determines whether or not all elements of a vector are non zero */
/* PARAMETER[v]: a vector of a numbers */
/* RETURN: 1 if all elements in the vector are non zero, and 0 otherwise. If the vector is empty, this function returns 1 */
func all(v) = native all(v)

/* ABSTRACT: Determines whether or not any element of a vector is non zero */
/* PARAMETER[v]: a vector of a numbers */
/* RETURN: 1 if any element in the vector is non zero, and 0 otherwise. If the vector is empty, this function returns 0 */
func any(v) = native any(v)

/* ABSTRACT: Given a map, return a vector that is just the keys of the map. The order of the elements in the returned vector is given by the order the elements were inserted into the map */
/* PARAMETER[d]: the map that we want to find the keys of */
/* RETURN: the keys of the map as specified by the description above */
func map_keys(d) = native map_keys(d)

/* ABSTRACT: Given a map, return a vector that is just the values of the map. The order of the elements in the returned vector is given by the order the elements were inserted into the map */
/* PARAMETER[d]: the map that we want to find the values of */
/* RETURN: the values of the map as specified by the description above */
func map_values(d) = native map_values(d)

/* ABSTRACT: Given a map, return a vector that is list of 2-vectors. The first element of each two-vector is a key of the map, and the second is the associated value. The order of the elements in the returned vector is given by the order the elements were inserted into the map */
/* PARAMETER[d]: the map that we want to find the items of */
/* RETURN: the items of the map as specified by the description above */
func map_items(d) = native map_items(d)

/* CATEGORY[18]: Math Utilities */

/* ABSTRACT: A constant for `e`, the sum of the recipriocals of the factorials of all non-negative integers. */
let E	= 2.7182818284590452353602874
/* ABSTRACT: A constant for pi, the ratio of the circumference of a circle to its diameter */
let PI  = 3.1415926535897932384626433
/* ABSTRACT: A constant for tau, the ratio of the circumference of a circle to its radius  */
let TAU = 2 * PI

/* ABSTRACT: A 3-vector whose elements are all zero. This constant is equal to `{0,0,0}`*/
let ZERO_V	 = { 0,  0,  0}

/* ABSTRACT: A 3-vector whose elements are all one. This constant is equal to `{1,1,1}` */
let ONE_V	 = { 1,  1,  1}

/* ABSTRACT: A 3-vector that represents a position located at the origin `{0,0,0}` */
/* REMARK: `ORIGIN` is technically an alias for @REF[ZERO_V], but semantically `ORIGIN` conveys the purpose better and is hence used more often */
/* IMPORTANT: This constant is used often enough to be worth memorizing. */
let ORIGIN   = { 0,  0,  0}

/* ABSTRACT: A 3-vector representing a vector that points straight left. This constant is equal to `{-1,0,0}` */
/* REMARK: `LEFT` is useful for some positional mesh operators, such as @REF[MovedNextTo] and @REF[MovedToSide] */
/* IMPORTANT: This constant is used often enough to be worth memorizing.
let LEFT	 = {-1,  0,  0}

/* ABSTRACT: A 3-vector representing a vector that points straight right. This constant is equal to `{1,0,0}` */
/* REMARK: `RIGHT` is useful for some positional mesh operators, such as @REF[MovedNextTo] and @REF[MovedToSide] */
/* IMPORTANT: This constant is used often enough to be worth memorizing.
let RIGHT	 = { 1,  0,  0}

/* ABSTRACT: A 3-vector representing a vector that points straight down. This constant is equal to `{0,-1,0}` */
/* REMARK: `DOWN` is useful for some positional mesh operators, such as @REF[MovedNextTo] and @REF[MovedToSide] */
/* IMPORTANT: This constant is used often enough to be worth memorizing.
let DOWN	 = { 0, -1,  0}

/* ABSTRACT: A 3-vector representing a vector that points straight up. This constant is equal to `{0,1,0}` */
/* REMARK: `UP` is useful for some positional mesh operators, such as @REF[MovedNextTo] and @REF[MovedToSide] */
/* IMPORTANT: This constant is used often enough to be worth memorizing.
let UP		 = { 0,  1,  0}

/* ABSTRACT: A 3-vector representing a vector that points forward (because Monocurl uses a right handed coordinate system, this is generally away from the screen). This constant is equal to `{0,0,1}` */
let FORWARD  = { 0,  0, 1}

/* ABSTRACT: A 3-vector representing a vector that points backward (because Monocurl uses a right handed coordinate system, this is generally towards the screen). This constant is equal to `{0,0,-1}` */
let BACKWARD = { 0,  0,  -1}

/* ABSTRACT: Applies the square root function to a given input number. */
/* PARAMETER[x]: the input number */
/* RETURN: the square root of the input number */
func sqrt(x) = x ** (1 / 2)

/* ABSTRACT: Applies the cube root function to a given input number. */
/* PARAMETER[x]: the input number */
/* RETURN: the cube root of the input number */
func cbrt(x) = x ** (1 / 3)

/* ABSTRACT: Finds the mean of a vector of numbers */
/* PARAMETER[x]: the input vector of numbers, which must contain at least one element */
/* RETURN: the sum of the elements of the input divided by the total number */
func mean(x) = native mean(x)

/* ABSTRACT: Finds the standard deviation of a vector of numbers */
/* PARAMETER[x]: the input vector of numbers, which must contain at least one element */
/* RETURN: the standard deviation of the vector of numbers */
func std_dev(x) = native std_dev(x)

/* ABSTRACT: Calculates @REF[E] to the power of the input value x */
/* PARAMETER[x]: the input value which will be treated as the exponent */
/* RETURN: e to the power of the input */
func exp(x) = E ** x

/* ABSTRACT: Calculates the natural log of the input */
/* PARAMETER[x]: the input value */
/* RETURN: the natural log of the input */
func ln(x) = native ln(x)

/* ABSTRACT: Calculates the logarithm (base 2) of the input */
/* PARAMETER[x]: the input value */
/* RETURN: the log base 2 of the input */
func log2(x) = native log2(x)

/* ABSTRACT: Calculates the logarithm (base 10) of the input */
/* PARAMETER[x]: the input value */
/* RETURN: the log base 10 of the input */
func log10(x) = native log10(x)

/* ABSTRACT: Calculates the logarithm (base provided by the user) of the input */
/* PARAMETER[a]: the base */
/* PARAMETER[b]: the input value */
/* RETURN: the log of the input value `b`, with base `a` */
func log(a, b) = native log(a,b)

/* ABSTRACT: Calculates the sin of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the sin of the input value */
func sin(x) = native sin(x)

/* ABSTRACT: Calculates the cos of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the cos of the input value */
func cos(x) = native cos(x)

/* ABSTRACT: Calculates the tan of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the tan of the input value */
func tan(x) = native tan(x)

/* ABSTRACT: Calculates the cot of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the cot of the input value */
func cot(x) = native cot(x)

/* ABSTRACT: Calculates the sec of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the sec of the input value */
func sec(x) = native sec(x)

/* ABSTRACT: Calculates the csc of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the csc of the input value */
func csc(x) = native csc(x)

/* ABSTRACT: Calculates the arcsin of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the arcsin of the input value */
func arcsin(x) = native arcsin(x)

/* ABSTRACT: Calculates the arccos of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the arccos of the input value */
func arccos(x) = native arccos(x)

/* ABSTRACT: Calculates the arctan of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the arctan of the input value */
func arctan(x) = native arctan(x)

/* ABSTRACT: Calculates the sinh of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the sinh of the input value */
func sinh(x) = (E ** x - E ** -x) / 2

/* ABSTRACT: Calculates the cosh of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the cosh of the input value */
func cosh(x) = (E ** x + E ** -x) / 2

/* ABSTRACT: Calculates the tanh of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the tanh of the input value */
func tanh(x) = (E ** x - E ** -x) / (E ** x + E ** -x)

/* ABSTRACT: Calculates the factorial of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the factorial of the input value */
func factorial(x) = native factorial(x)

/* ABSTRACT: Calculates the sigmoid of the input value */
/* PARAMETER[x]: the input value */
/* RETURN: the sigmoid of the input value */
func sigmoid(x) = 1 / (1 + E ** -x)

/* ABSTRACT: Calculates the number of ways of choose `r` objects from a collection of `n` items */
/* PARAMETER[n]: the size of the collection */
/* PARAMETER[r]: the number of items we are trying to choose */
/* RETURN: the the number of ways of choose `r` objects from a collection of `n` items */
func choose(n, r) = native choose(n, r)

/* ABSTRACT: Calculates the number of ways of permute `r` objects from a collection of `n` items */
/* PARAMETER[n]: the size of the collection */
/* PARAMETER[r]: the number of items we are trying to permute */
/* RETURN: the the number of ways of permute `r` objects from a collection of `n` items */
func permute(n, r) = native permute(n, r)

/* ABSTRACT: Calculates the greatest common divisor between two integers */
/* PARAMETER[n]: the first integer */
/* PARAMETER[m]: the second integer */
/* RETURN: the greater common divisor of the two provided integers*/
func gcd(n, m) = native gcd(n, m)

/* ABSTRACT: Calculates the least common multiple between two integers */
/* PARAMETER[n]: the first integer */
/* PARAMETER[m]: the second integer */
/* RETURN: the least common multiple of the two provided integers*/
func lcm(n, m) = n * m / gcd(n, m)

/* ABSTRACT: Calculates the greater value of the two provided numbers */
/* PARAMETER[n]: the first numbers */
/* PARAMETER[m]: the second number */
/* RETURN: the greater value of the two provided numbers */
func max(n, m) = native max(n, m)

/* ABSTRACT: Calculates the lesser value of the two provided numbers */
/* PARAMETER[n]: the first numbers */
/* PARAMETER[m]: the second number */
/* RETURN: the lesser value of the two provided numbers */
func min(n, m) = native min(n, m)

/* ABSTRACT: Calculates the greater value of the provided numbers and 0 */
/* PARAMETER[x]: the input numbers */
/* RETURN: the greater value of the provided numbers and 0 */
func relu(x) = max(x, 0)

/* ABSTRACT: Calculates the absolute value of the input number */
/* PARAMETER[x]: the input numbers */
/* RETURN: the the absolute value of the input number */
func abs(x) = native abs(x)

/* ABSTRACT: Clamps an input to a range. The value of l should be less than or equal to the value of r */
/* PARAMETER[l]: the number denoting the start of the range*/
/* PARAMETER[x]: the number that we want to clamp */
/* PARAMETER[r]: the number denoting the end of the range*/
/* RETURN: r if x is greater than r, l if x is less than l, and otherwise x is returned.
func clamp(l, x, r) = native clamp(l, x ,r)

/* ABSTRACT: Determines whether or not the input integer is prime */
/* PARAMETER[n]: the input integer */
/* RETURN: 1 if the input integer is prime, and 0 otherwise */
func is_prime(n) = native is_prime(n)

/* ABSTRACT: Determines the sign of the input number */
/* PARAMETER[x]: the input value */
/* RETURN: 1 if the input number is positive, 0 if the input is zero, and -1 otherwise */
func sign(x) = native sign(x)

/* ABSTRACT: Calculates the first integer modulo the second integer */
/* PARAMETER[n]: the first integer */
/* PARAMETER[m]: the second integer */
/* RETURN: the first integer modulo the second integer */
func mod(n, m) = native mod(n, m)

/* ABSTRACT: Calculates the input value rounded towards negative infintiy */
/* PARAMETER[x]: the input value */
/* RETURN: the input value rounded towards negative infintiy */
func floor(x) = native floor(x)

/* ABSTRACT: Calculates the input value rounded towards the nearest integer */
/* PARAMETER[x]: the input value */
/* RETURN: the input value rounded towards the nearest integer */
func round(x) = native round(x)

/* ABSTRACT: Calculates the input value rounded towards positive infinity */
/* PARAMETER[x]: the input value */
/* RETURN: the input value rounded towards positive infinity */
func ceil(x) = native ceil(x)

/* ABSTRACT: Calculates the input value rounded towards zero */
/* PARAMETER[x]: the input value */
/* RETURN: the input value rounded towards zero */
func trunc(x) = native trunc(x)

/* ABSTRACT: Calculates a random number in the half open interval [low, high) */
/* REMARK: This function can only be used at the top level. That is, you cannot use it within a function (as that would destroy the purity of functions). If you really do need randomness in a function, you should take in a random seed as a parameter.
/* REMARK: Monocurl ensures that random functions are predictable in the following sense. Any rerun of a scene will always produce the exact same output, even if it references random functions. This generally helps for debugging and scene creation. However, this may also be unexpected to some users of the random function so be weary. */
/* PARAMETER[low]: the inclusive starting point of the half open interval */
/* PARAMETER[high]: the exclusive ending point of the half open interval */
/* RETURN: a random number in the half open interval [low, high) */
func random(low, high) = native random(low, high)

/* ABSTRACT: Calculates a random integer in the half open interval [low, high) */
/* REMARK: This function can only be used at the top level. That is, you cannot use it within a function (as that would destroy the purity of functions). If you really do need randomness in a function, you should take in a random seed as a parameter.
/* REMARK: Monocurl ensures that random functions are predictable in the following sense. Any rerun of a scene will always produce the exact same output, even if it references random functions. This generally helps for debugging and scene creation. However, this may also be unexpected to some users of the random function so be weary. */
/* PARAMETER[low]: the inclusive starting point of the half open interval */
/* PARAMETER[high]: the exclusive ending point of the half open interval */
/* RETURN: a random integer in the half open interval [low, high) */
func randint(low, high) = native randint(low, high)

/* ABSTRACT: Calculates the magnitude of the given vector */
/* PARAMETER[v]: a vector of numbers */
/* RETURN: the magnitude of the given vector */
func norm(v) = native norm(v)

/* ABSTRACT: Calculates the normalized version of a vector. If the vectors magnitude is below some unspecified value epsilon, then the original vector is return instead. In all other cases, the resultant vector is a unit vector pointing in the same direction as the input.*/
/* PARAMETER[v]: a vector of numbers */
/* RETURN: the normalized vector */
func normalize(v) = native normalize(v)

/* ABSTRACT: Calculates the dot product between two vectors of the same length. This is done by taking the sum of the element-wise products of entries in u and v. If their lengths are zero, the ouput is also zero. In some countries, the dot product is known as the scalar product. */
/* PARAMETER[u]: a vector of numbers */
/* PARAMETER[v]: a vector of numbers with the same length as u */
/* RETURN: the dot product between u and v */
func dot(u,v) = native dot(u,v)

/* ABSTRACT: Calculates the cross product between u and v. If both vectors are of dimension 2, this returns the z component of the cross product between u and v as if u and v were to live in the third dimension with z component zero. Otherwise, this returns a 3-vector according to the standard definition of a cross product. In some countries, the cross  product is known as the vector product. */
/* PARAMETER[u]: a vector of numbers of dimension 2 or 3 */
/* PARAMETER[v]: a vector of numbers with the same length as u */
/* RETURN: the cross product between u and v */
func cross_product(u,v) = native cross(u,v)

/* ABSTRACT: Calculates the projection of u onto v. That is, this calculates a vector pointing in the direction of v whose magnitude is the size of the component of u that lies along v */
/* PARAMETER[u]: a vector of numbers */
/* PARAMETER[v]: a vector of numbers with the same length as u */
/* RETURN: the projection of u onto v */
func proj(u,v) = native proj(u,v)

/* ABSTRACT: Calculates addition of two vectors */
/* PARAMETER[u]: a vector of numbers */
/* PARAMETER[v]: a vector of numbers with the same length as u */
/* RETURN: a vector with the same length of u or v, where each entry is given by the sum of the corresponding entries in u and v */
func vec_add(u,v) = native vec_add(u,v)

/* ABSTRACT: Calculates multiplication of two vectors. In fact, if either u or v is given as a scalar, then scalar multiplfication is performed. */
/* PARAMETER[u]: a vector of numbers (or a scalar) */
/* PARAMETER[v]: a vector of numbers with the same length as u (or a scalar) */
/* RETURN: a vector with the same length of u or v, where each entry is given by the sum of the corresponding entries in u and v */
func vec_mul(u,v) = native vec_mul(u,v)

/* ABSTRACT: Replaces substrings of a string with the target */
/* PARAMETER[str]: the original string */
/* PARAMETER[substr]: the substr that we want to replace */
/* PARAMETER[with]: the string that replaces the substr */
/* RETURN: a string where all of the substrings have been adjusted */
func str_replace(str, substr, with) = native str_replace(str, substr, with)

/* ABSTRACT: Calculates subtraction of two vectors */
/* PARAMETER[u]: a vector of numbers */
/* PARAMETER[v]: a vector of numbers with the same length as u */
/* RETURN: a vector with the same length of u or v, where each entry is given by the difference of the corresponding entries in u and v */
func vec_sub(u,v) = native vec_add(u, native vec_mul(-1, v))

/* CATEGORY[1]: General Scene Elements */

/* ABSTRACT: Only used for creating the scene @REF[camera] variable. Cameras are useful for easily translating the entire scene, and especially useful for getting multiply angles in a 3d context. */
/* REMARK: While camera works with @REF[Lerp], there are some gimbal-lock issues and it's recommended you use @REF[CameraLerp] instead */
/* PARAMETER[near]: a number representing the near clipping plane */
/* PARAMETER[far]: a number representing the far clipping plane. Any point that has an effective z distance outside either of the two clipping planes will not be shown on screen.  */
/* PARAMETER[up]: a 3-vector representing what the camera's local y axis is */
/* PARAMETER[origin]: a 3-vector representing where the camera should be positioned */
/* PARAMETER[target]: a 3-vector representing where the camera should be pointing towards */
/* PARAMETER[forward]: a 3-vector representing the direction the camera should be looking towards */
/* RETURN: returns an internal representation of a camera. We do not recommend you modify the result (of course, you are free to modify the result by modifying functor attributes, just dont modify the raw, unwrapped result) */
func Camera([plane] {[main] {near, far}}, up, [direction] {[main] {origin, target}, [forward] {origin, forward}}) = identity:
	var forw = forward
	if direction == 0
		forw = vec_sub(target, origin)
	let right = cross_product(forw, up)
	let true_up = normalize(cross_product(right, forw))
	element: {near, far, true_up, origin, normalize(forw)}

/* CATEGORY[2]: Geometric Meshes */

/* ABSTRACT: Produces a single dot mesh in the specified location */
/* PARAMETER[point]: a 3-vector that specifies the location at which to place the dot */
/* PARAMETER[normal]: a 3-vector which specifies the plane the dot occupies, if none is provided, a default of `{0,0,1}` is assumed */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default color, which is white */
/* PARAMETER[dot]: a 4-vector specifying the color of the dot */
/* RETURN: a mesh that has a singular dot with the specified properties */
func Dot([config] {[main] {point}, [parameterized] {point, normal}}, tag, [color] {[default] {}, [colored] {dot}}) = native dot_mesh(config, point, normal, tag, color, dot)


/* ABSTRACT: Produces a single circular mesh */
/* IMPORTANT: Circles are used often enough to be worth memorizing */
/* PARAMETER[center]: a 3-vector representing the center of the circle */
/* PARAMETER[radius]: a number representing the radius of the circle */
/* PARAMETER[samples]: the amount of vertices to put in the circle */
/* PARAMETER[normal]: a 3-vector representing the normal of the circle, defaults to `{0,0,1}` */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a circle according to the specifications */
func Circle([config] {[main] {center, radius}, [parameterized] {center, radius, samples, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native circle(config, center, radius, samples, normal, tag, color, stroke, fill)

/* ABSTRACT: Produces an annulus mesh. This looks like a circle with a circular hole in its center. */
/* PARAMETER[center]: a 3-vector representing the center of the annulus */
/* PARAMETER[inner]: a number representing the inner radius of the annulus */
/* PARAMETER[outer]: a number representing the outer radius of the annulus. Must be >= than the inner radius. */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a annulus according to the specifications */
func Annulus([config] {[main] {center, inner, outer}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native annulus(config, center, inner, outer, tag, color, stroke, fill)


/* ABSTRACT: Produces a square mesh. */
/* IMPORTANT: Squares are used often enough to be worth memorizing */
/* PARAMETER[center]: a 3-vector representing the center of the square */
/* PARAMETER[width]: a number representing the width of the square */
/* PARAMETER[normal]: a 3-vector representing the normal of the square, defaults to `{0,0,1}`. Note that the direction of the minor and major axes are only guaranteed to be normal to the normal, but the exact direction is somewhat unspecified. This behavior is ugly and may be changed in the future. */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a square according to the specifications */
func Square([config] {[main] {center, width}, [parameterized] {center, width, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native rect(config, center, width, width, normal, tag, color, stroke, fill)

/* ABSTRACT: Produces a rectangular mesh. */
/* IMPORTANT: Rects are used often enough to be worth memorizing */
/* PARAMETER[center]: a 3-vector representing the center of the rect */
/* PARAMETER[width]: a number representing the width of the rect */
/* PARAMETER[height]: a number representing the height of the rect */
/* PARAMETER[normal]: a 3-vector representing the normal of the mesh, defaults to `{0,0,1}`. Note that the direction of the minor and major axes are only guaranteed to be normal to the normal, but the exact direction is somewhat unspecified. This behavior is ugly and may be changed in the future. */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a rectangle according to the specifications */
func Rect([config] {[main] {center, width, height}, [parameterized] {center, width, height, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native rect(config, center, width, height, normal, tag, color, stroke, fill)

/* ABSTRACT: Produces a rectangular polygon mesh. Note that you do not really have a lot of control on the initial angle offset, so you may want to play around with composing a regular polygon with a @REF[Rotated] operator. */
/* PARAMETER[center]: a 3-vector representing the center of the polygon */
/* PARAMETER[n]: an integer representing the amount of vertices to include in the regular polygon */
/* PARAMETER[circumradius]: the circumradius of the polygon (that is, the radius from any of the vertices to the center) */
/* PARAMETER[normal]: a 3-vector representing the normal of the mesh, defaults to `{0,0,1}`. Note that the direction of the minor and major axes are only guaranteed to be normal to the normal, but the exact direction is somewhat unspecified. This behavior is ugly and may be changed in the future. */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a rectangular polygon according to the specifications */
func RegularPolygon([config] {[main] {center, n, circumradius}, [parameterized] {center, n, circumradius, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native regular_polygon(config, center, n, circumradius, normal, tag, color, stroke, fill)

/* ABSTRACT: Produces a polygon mesh. Not so important that you have to memorize, but it does come up somewhat often. */
/* PARAMETER[vertices]: a vector of 3-vectors representing the counter clockwise order of the vertices. */
/* PARAMETER[normal_hint]: a 3-vector representing the normal hint of the mesh, defaults to `{0,0,1}`. Useful if the polygon is non planar, and you want to provide a hint when the regular normal calculation algorithm is failing.*/
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: a mesh that contains a polygon according to the specifications */
func Polygon([config] {[main] {vertices}, [normal_hint] {vertices, normal_hint}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native polygon(config, vertices, normal_hint, tag, color, stroke, fill)

/* ABSTRACT: Produces a polyline. Not so important that you have to memorize, but it does come up somewhat often. */
/* PARAMETER[vertices]: a vector of 3-vectors representing the counter clockwise order of the vertices. Note that if the final vertex is equivalent to the initial vertex, then the mesh is closed and is considered a loop, otherwise it is bounded by dots (which by default are clear, but still do exist) */
/* PARAMETER[normal_hint]: a 3-vector representing the normal hint of the mesh, defaults to `{0,0,1}`. Useful if the polygon is non planar, and you want to provide a hint when the regular normal calculation algorithm is failing.*/
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no dot colors */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[dot]: a 4-vector representing the color of the dots */
/* RETURN: a mesh that contains a polyline according to the specifications */
func Polyline([config] {[main] {vertices}, [normal_hint] {vertices, normal_hint}}, tag, [color] {[default] {}, [stroke] {stroke}, [dotted] {stroke, dot}}) = native polyline(config, vertices, normal_hint, tag, color, stroke, dot)

/* ABSTRACT: Produces a line mesh. */
/* IMPORTANT: Lines occur often enough that they are worth memorizing */
/* PARAMETER[start]: either a 3-vector or a mesh-tree. In the case of the latter, a line is drawn a small buffer away from the mesh in the direction of the the ending vector */
/* PARAMETER[end]: either a 3-vector or a mesh-tree. In the case of the latter, a line is drawn a small buffer away from the mesh in the direction of the the start vector */
/* PARAMETER[normal]: a 3-vector representing the normal of the mesh, defaults to `{0,0,1}` */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no dot colors */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[dot]: a 4-vector representing the color of the dots */
/* RETURN: a mesh that contains a line according to the specifications */
func Line([config] {[main] {start, end}, [parameterized] {start, end, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [dotted] {stroke, dot}}) = native line(config, start, end, normal, tag, color, stroke, dot)

/* ABSTRACT: Produces an arrow mesh. */
/* IMPORTANT: Arrows occur often enough that they are worth memorizing */
/* PARAMETER[start]: either a 3-vector or a mesh-tree. In the case of the latter, an arrow is drawn a small buffer away from the mesh in the direction of the the ending vector */
/* PARAMETER[end]: either a 3-vector or a mesh-tree. In the case of the latter, a line is drawn a small buffer away from the mesh in the direction of the the start vector. Note that the arrow head points towards the end. */
/* PARAMETER[normal]: a 3-vector representing the normal of the mesh, defaults to `{0,0,1}` */
/* PARAMETER[path_arc]: if the arrow was to be embedded in the arc of a large circle, the path_arc dictates how many radians it would take. The default is zero. A negative number makes the arrow curve in the opposite direction. */
/* PARAMETER[tag]: a vector of numbers that is used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with a white fill. Note that an uprank is forced.*/
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. */
/* RETURN: a mesh created according to the specifications */
func Arrow([config] {[main] {start, end}, [parameterized] {start, end, normal, path_arc}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native arrow(config, start, end, normal, path_arc, tag, color, stroke, fill)

/* ABSTRACT: Creates an arc mesh based on specified parameters. */
/* PARAMETER[center]: a 3-vector denoting the center coordinates of the arc */
/* PARAMETER[radius]: a scalar value representing the radius of the arc */
/* PARAMETER[theta_start]: a numeric value indicating the starting angle of the arc in radians */
/* PARAMETER[theta_end]: a numeric value indicating the ending angle of the arc in radians */
/* PARAMETER[normal]: a 3-vector representing the normal of the arc's plane; defaults to `{0,0,1}` */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the fill. Note that providing this value will force an uprank */
/* RETURN: generates a mesh conforming to the specified arc parameters */
func Arc([config] {[main] {center, radius, theta_start, theta_end}, [parameterized] {center, radius,theta_start, theta_end, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native arc(config, center, radius, theta_start, theta_end, normal, tag, color, stroke, fill)

/* ABSTRACT: Generates a capsule-shaped mesh based on provided parameters. */
/* PARAMETER[start_center]: a 3-vector indicating the center coordinates of the capsule's start hemisphere */
/* PARAMETER[end_center]: a 3-vector indicating the center coordinates of the capsule's end hemisphere */
/* PARAMETER[in_rad]: a scalar value representing the corner radius of the capsule (i.e. how rounded it is) */
/* PARAMETER[out_rad]: a scalar value representing the radius of the outer hemispheres of the capsule (i.e., how much it extends from the start or end points) */
/* PARAMETER[normal]: a 3-vector representing the normal of the capsule; defaults to `{0,0,1}` */ 
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the capsule's stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the capsule's fill. Providing this value will force an uprank */
/* RETURN: generates a mesh conforming to the specified capsule parameters */
func Capsule([config] {[main] {start_center, end_center, in_rad, out_rad}, [normal] {start_center, end_center, in_rad, out_rad, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native capsule(config, start_center, end_center, normal, in_rad, out_rad, tag, color, stroke, fill)

/* ABSTRACT: Generates a triangle mesh based on specified parameters. */
/* PARAMETER[p]: a 3-vector representing the first vertex of the triangle */
/* PARAMETER[q]: a 3-vector representing the second vertex of the triangle */
/* PARAMETER[r]: a 3-vector representing the third vertex of the triangle */
/* PARAMETER[normal_hint]: a 3-vector providing a hint for the normal direction of the triangle; defaults to the calculated normal based on the vertices */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the triangle's stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the triangle's fill. Providing this value will force an uprank */
/* RETURN: generates a mesh conforming to the specified triangle parameters */
func Triangle([config] {[main] {p, q, r}, [normal_hint] {p, q, r, normal_hint}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native triangle(config, p, q, r, normal_hint, tag, color, stroke, fill)

/* ABSTRACT: Creates a spherical mesh based on specified parameters. */
/* REMARK: I don't think the sphere looks particular good right now (mostly because I'm not super good at shaders and had a little trouble getting the lighting to look proper). You might want to @REF[PointMapped] a ColorGrid to create a parameteric surface of a sphere. That generally looks better */
/* PARAMETER[center]: a 3-vector indicating the center coordinates of the sphere */
/* PARAMETER[radius]: a scalar value representing the radius of the sphere */
/* PARAMETER[sample_depth]: a numeric value determining the sampling depth for mesh refinement; higher values improve mesh quality but increase computation time */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is to have a white surface*/
/* PARAMETER[surface]: a 4-vector representing the color of the sphere's surface */
/* RETURN: generates a mesh conforming to the specified sphere parameters */
func Sphere([config] {[main] {center, radius}, [parameterized] {center, radius, sample_depth}}, tag, [color] {[default] {}, [color] {surface}}) = native sphere(config, center, radius, sample_depth, tag, color, surface)

/* ABSTRACT: Generates a rectangular prism mesh based on specified parameters. */
/* PARAMETER[center]: a 3-vector indicating the center coordinates of the rectangular prism */
/* PARAMETER[dimensions]: a 3-vector specifying the dimensions (width, height, depth) of the rectangular prism */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is to have a white surface */
/* PARAMETER[surface]: a 4-vector representing the color of the rectangular prism's surface */
/* RETURN: generates a mesh conforming to the specified rectangular prism parameters */
func RectangularPrism([config] {[main] {center, dimensions}}, tag, [color] {[default] {}, [color] {surface}}) = native rectangular_prism(config, center, dimensions, tag, color, surface)

/* ABSTRACT: Generates a cylindrical mesh based on specified parameters. */
/* PARAMETER[center]: a 3-vector indicating the center coordinates of the cylinder's base */
/* PARAMETER[radius]: a scalar value representing the radius of the cylinder */
/* PARAMETER[height]: a scalar value indicating the height of the cylinder */
/* PARAMETER[direction]: a 3-vector representing the direction or orientation of the cylinder; defaults to the positive z-axis */
/* PARAMETER[sample_count]: a numeric value determining the number of samples for mesh refinement; higher values improve mesh quality but increase computation time */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is to have a white surface */
/* PARAMETER[surface]: a 4-vector representing the color of the cylinder's surface */
/* RETURN: generates a mesh conforming to the specified cylindrical parameters */
func Cylinder([config] {[main] {center, radius, height}, [parameterized] {center, radius, height, direction, sample_count}}, tag, [color] {[default] {}, [color] {surface}}) = native cylinder(config, center, radius, height, direction, sample_count, tag, color, surface)

/* CATEGORY[3]: Visual Meshes */

/* ABSTRACT: Generates a Bezier curve mesh based on specified control points. */
/* PARAMETER[control_points]: a list of control points defining the Bezier curve. In particular, you must provide 3n+1 3-vectors for some integer n. The first four vertices form a cubic curve. Then, the window shifts by 3 and vertices at indices 3, 4, 5, and 6, form the next set and so on. If the final point is equal to the initial point, the loop is closed. Otherwise, it is bounded by invisible dots. */
/* PARAMETER[tag]: a vector of numbers used as the mesh's tag */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no fill */
/* PARAMETER[stroke]: a 4-vector representing the color of the curve's stroke */
/* PARAMETER[fill]: a 4-vector representing the color of the curve's fill. Providing this value forces an uprank. */
/* RETURN: generates a Bezier curve conforming to the specified control points */
func Bezier(control_points, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native bezier(control_points, tag, color, stroke, fill)

/* ABSTRACT: Generates a color grid mesh based on specified parameters. A color grid is essentially a set of small rectangles, and each rectangle in the grid gets its color from a user provided function. Moreover, you can mask out only a subset of the rectangles to be shown. The key feature is that this all provided in a single mesh, which basically makes this significantly more perfamant than creating 10000 rectangles as you might do otherwise. */
/* IMPORTANT: A color grid is extremely versatile and we recommend you play around with it. In particular, it's great for creating parameteric surfaces in conjunction with @REF[PointMapped] (this is how the Monocurl log was created). You might also want to refer to @REF[keyframe_lerp] for help on creating gradients. */ 
/* PARAMETER[x_min]: Define the minimum x-coordinate of the grid */
/* PARAMETER[x_max]: Define the maximum x-coordinate of the grid */
/* PARAMETER[y_min]: Define the minimum y-coordinate of the grid */
/* PARAMETER[y_max]: Define the maximum y-coordinate of the grid */
/* PARAMETER[x_step]: Define the step size for x-coordinate (how wide each sub rectangle should be) */
/* PARAMETER[y_step]: Define the step size for y-coordinate (how tall each sub rectangle should be) */
/* PARAMETER[mask(pos)]: Function to define mask for specific positions (whether or not a sub rectangle should be included or not). Return 1 if it should be used, and zero otherwise. */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[color_at(pos)]: Function to define color at specific positions. Pos is a 3-vector consisting of the global x, y, and z positions. */
/* PARAMETER[stroke]: A 4-vector representing the color of the grid's stroke (defaults to white) */
/* RETURN: a color grid mesh based on the above specification */
func ColorGrid([points] {[main] {x_min, x_max, y_min, y_max}, [step] {x_min, x_max, y_min, y_max, x_step, y_step}, [mask] {x_min, x_max, y_min, y_max, x_step, y_step, mask(pos)}}, tag, [color] {[auto_stroke] {color_at(pos)}, [custom_stroke] {color_at(pos), stroke}}) = native color_grid(points, x_min, x_max, y_min, y_max, x_step, y_step, mask!, tag, color, color_at!, stroke)

/* ABSTRACT: Generates a field mesh based on specified parameters. A field consists of a collection of meshes at various evenly spaced positions. */
/* REMARK: The Field function is pretty versatile. It's suitable for representing scalar or vector fields across a region defined by the specified parameters. However, it can also be used for things outside of a mathematical field, if we just want to place a bunch of meshes at various grid points. */
/* PARAMETER[x_min]: Define the minimum x-coordinate of the field */
/* PARAMETER[x_max]: Define the maximum x-coordinate of the field */
/* PARAMETER[y_min]: Define the minimum y-coordinate of the field */
/* PARAMETER[y_max]: Define the maximum y-coordinate of the field */
/* PARAMETER[x_step]: Define the step size for x-coordinate (x-wise separation of adjacent sub_meshes) */
/* PARAMETER[y_step]: Define the step size for y-coordinate (y-wise separation of adjacent sub_meshes) */
/* PARAMETER[mask(pos)]: Function to define the mask for specific positions (whether or not to include a mesh at a particular position). Return a non zero value if it should be used, and zero otherwise. */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[mesh_at(pos)]: Function to define mesh at specific positions. Pos is a 3-vector consisting of the global x, y, and z positions. */
/* RETURN: a mesh-tree of the resultant generated meshes. There are no guarantees on the specific shape of the mesh-tree (i.e. whether it is flattened or not) */
func Field([points] {[main] {x_min, x_max, y_min, y_max}, [step] {x_min, x_max, y_min, y_max, x_step, y_step}, [mask] {x_min, x_max, y_min, y_max, x_step, y_step, mask(pos)}}, mesh_at(pos)) = native field(points, x_min, x_max, y_min, y_max, x_step, y_step, mask!, mesh_at!)

/* ABSTRACT: Generates a half-vector mesh based on specified parameters. This looks like a regular vector (an arrow if you are unfamiliar)), but cut in half vertically (only the right half is kept). */
/* PARAMETER[tail]: A 3-vector denoting the starting point of the half-vector */
/* PARAMETER[delta]: A 3-vector indicating the change or direction of the half-vector */
/* PARAMETER[normal]: A 3-vector representing the normal direction of the half-vector */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white stroke with white fill. Note that an uprank is always forced*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a half-vector mesh conforming to the specified parameters */
func HalfVector([config] {[main] {tail, delta}, [normal] {tail, delta, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native half_vector(config, tail, delta, normal, tag, color, stroke, fill)

/* ABSTRACT: Generates a vector mesh based on specified parameters. This looks like an arrow from the start to the end point */
/* PARAMETER[tail]: A 3-vector denoting the starting point of the vector */
/* PARAMETER[delta]: A 3-vector indicating the change or direction of the vector */
/* PARAMETER[normal]: A 3-vector representing the normal direction of the vector */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white stroke with white fill. Note that an uprank is always forced*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a vector mesh conforming to the specified parameters */
func Vector([config] {[main] {tail, delta}, [normal] {tail, delta, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native vector(config, tail, delta, normal, tag, color, stroke, fill)

/* ABSTRACT: Generates a plane mesh based on specified parameters. */
/* PARAMETER[normal]: A 3-vector representing the normal direction of the plane */
/* PARAMETER[dist]: A scalar value indicating the distance from the origin along the normal */
/* PARAMETER[width]: A scalar value representing the width of the plane */
/* PARAMETER[height]: A scalar value representing the height of the plane */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white stroke with white fill. Note that an uprank is always forced*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a plane mesh conforming to the specified parameters */
func Plane([config] {[main] {normal, dist, width, height}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native plane(config, normal, dist, width, height, tag, color, stroke, fill)

/* ABSTRACT: Generates an image mesh based on specified parameters. To use images, first go to the media tab, import an image, and name it appropriately. Then, type the name into the name field. */
/* PARAMETER[name]: Name or reference identifier for the image. Should be specified using a str (i.e. `"image_i_named_in_media.png"`*/
/* PARAMETER[center]: A 3-vector indicating the center coordinates of the image */
/* PARAMETER[width]: A scalar value representing the width of the image */
/* PARAMETER[height]: A scalar value representing the height of the image */
/* PARAMETER[normal]: A 3-vector representing the normal direction of the image */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, no stroke with white fill. Note that an uprank is always forced. Second note, in the context of images, fill colors represent channel multipliers. */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill. Note, in the context of images, fill colors represent channel multipliers. */
/* RETURN: Generates an image mesh conforming to the specified parameters */
func Image(name, [config] {[main] {center, width, height}, [parameterized] {center, width, height, normal}}, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native image(name, config, center, width, height, normal, tag, color, stroke, fill)

/* CATEGORY[4]: Textual Meshes */

/* ABSTRACT: Generates a text mesh based on specified parameters. */
/* IMPORTANT: Text is extremely important, and definitely memorize both Text and the tagging mechanics */
/* PARAMETER[text]: Text string to be rendered. In particular, it uses latex. Of extreme important is the tagging mechanics. In the text string, there is a special latex function called `\pin{tag_number}{content}`. If you do this, then in the resultant mesh-tree, the content associated with that pin will have the specified tag_number. However, the tag_number must be an integer from 0 to 254. You can also do `\rowpin{tag_a}{tag_b}{content}`, to give the tag a two vector of consistent of `{tag_a, tag_b}`. Content that is not enclosed in any such pin field will be given the empty tag. */
/* PARAMETER[scale]: Scalar value indicating the size or scale of the text. This isn't in the same coordinates as world space, and theres not a guarantee on the conversion (you'll have to more or less wing it) */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with a stroke that has 0 opacity*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a text mesh conforming to the specified parameters */
func Text(text, scale, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native mesh_text(text, scale, 0, color, stroke, fill)

/* ABSTRACT: Generates a tex mesh based on specified parameters. Tex is essentially the same as @REF[Text], but you are in math mode by default. */
/* IMPORTANT: Tex is extremely important, and definitely memorize both Tex and the tagging mechanics */
/* PARAMETER[tex]: Tex string to be rendered. In particular, it uses latex. Of extreme important is the tagging mechanics. In the tex string, there is a special latex function called `\pin{tag_number}{content}`. If you do this, then in the resultant mesh-tree, the content associated with that pin will have the specified tag_number. However, the tag_number must be an integer from 0 to 255. Content that is not enclosed in any such pin field will be given the empty tag. */
/* PARAMETER[scale]: Scalar value indicating the size or scale of the tex. This isn't in the same coordinates as world space, and theres not a guarantee on the conversion (you'll have to more or less wing it) */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with a stroke that has 0 opacity*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a tex mesh conforming to the specified parameters */
func Tex(tex, scale, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native mesh_text({"\[", tex, "\]"}, scale, 0, color, stroke, fill)

/* ABSTRACT: Generates a brace (`{`) that is placed next to a mesh and with a matched width. */
/* PARAMETER[mesh]: The mesh-tree, the entirety of which will be used for this operation */
/* PARAMETER[root]: The root of the mesh-tree. This provides the container of all possible meshes we want to select from */
/* PARAMETER[tag_predicate(tag)]: For any given mesh in root, the user specifies whether or not the mesh should be surrounded by the brace. The function is given the tag of the mesh in consideration. If a non zero value is returned then the mesh is included in calculating the brace size. Otherwise, it is ignored. */
/* PARAMETER[dir]: A 3-vector specifying the direction relative to the selected mesh to which the brace should be placed */
/* PARAMETER[tag]: A vector of numbers used as the result's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with a stroke that has 0 opacity*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: a mesh-tree that gives the brace next to the selected mesh in the appropriate direction. The shape of the mesh-tree is unspecified */
func Brace([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, dir, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native mesh_brace(mesh_tree, mesh, tag_predicate!, dir, 1, tag, color, stroke, fill)

/* ABSTRACT: Generates a something that looks like a horizontal I-Beam measuring a specified mesh and with a matched width. */
/* PARAMETER[mesh]: The mesh-tree, the entirety of which will be used for this operation */
/* PARAMETER[root]: The root of the mesh-tree. This provides the container of all possible meshes we want to select from */
/* PARAMETER[tag_predicate(tag)]: For any given mesh in root, the user specifies whether or not the mesh should be surrounded by the measuring. The function is given the tag of the mesh in consideration. If a non zero value is returned then the mesh is included in calculating the measure size. Otherwise, it is ignored. */
/* PARAMETER[dir]: A 3-vector specifying the direction relative to the selected mesh to which the measure should be placed */
/* PARAMETER[tag]: A vector of numbers used as the result's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with a stroke that has 0 opacity*/
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* RETURN: a mesh-tree that gives the measure next to the selected mesh in the appropriate direction. The shape of the mesh-tree is unspecified.  */
func Measure([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, dir, tag, [color] {[default] {}, [stroke] {stroke}}) = native mesh_measure(mesh_tree, mesh, tag_predicate!, dir, tag, color, stroke)

/* ABSTRACT: Generates a label text placed on a specific mesh in the given direction. */
/* PARAMETER[mesh]: The mesh-tree on which the label will be placed */
/* PARAMETER[str]: The text string for the label */
/* PARAMETER[scale]: Scalar value indicating the size or scale of the label text */
/* PARAMETER[dir]: A 3-vector specifying the direction relative to the selected mesh where the label should be placed */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with zero stroke opacity. */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: The given label mesh-tree. */
func Label(mesh, str, scale, dir, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = identity:
	let ret = native mesh_text(str, scale, 0, color, stroke, fill)
	element: native mesh_next_to(0, ret, identity!, mesh, dir)

/* ABSTRACT: Generates a numerical value displayed as a mesh in the scene. */
/* PARAMETER[value]: The numerical value to be displayed */
/* PARAMETER[precision]: The decimal precision of the displayed number (up to 9 digits) */
/* PARAMETER[scale]: Scalar value indicating the size or scale of the displayed number */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white fill with a clear stroke */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: A mesh-tree that is the numerical value as a series of meshes */
func Number(value, precision, scale, tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native mesh_number(value, precision, scale, tag, color, stroke, fill)

/* CATEGORY[5]: Graphing Meshes */

/* ABSTRACT: Generates a one-dimensional axis mesh with ticks, labels, and units along the X-axis on a specified plane. */
/* PARAMETER[center]: A 3-vector indicating the center coordinates of the axis */
/* PARAMETER[pos_x_axis]: A 3-vector indicating the direction of positive X-axis */
/* PARAMETER[normal]: A 3-vector representing the normal direction of the plane */
/* PARAMETER[tag]: A vector of numbers used as the axis's tag */
/* PARAMETER[color]: A 4-vector representing the color for rendering the axis */
/* PARAMETER[x_unit]: Unit for the X-axis. That is, one unit in world space should correspond to how many units in the axis? */
/* PARAMETER[x_rad]: Radius of the X-axis, which basically says that x_max should be +x_rad and x_min should be -x_rad */
/* PARAMETER[x_min]: Minimum value for the X-axis. Should be <= 0 */
/* PARAMETER[x_max]: Maximum value for the X-axis. Should be >= 0 */
/* PARAMETER[x_tick_step]: Step size for ticks on the X-axis (measured in axis coordinates)  */
/* PARAMETER[x_label]: A textual label for the X-axis. Displayed right next to the end of the positive X-axis */
/* PARAMETER[x_label_rate]: Rate for displaying X-axis labels. In particular, a numeric label will be assigned every `x_label_rate` ticks. Note you can turn these off entirely by setting a value of 0 */
/* RETURN: A mesh-tree according to the above specifications */
func Axis1d([plane] {[main] {center}, [normal] {center, pos_x_axis, normal}}, [x] {[main] {x_unit, x_rad}, [interval] {x_unit, x_min, x_max}, [step] {x_unit, x_min, x_max, x_tick_step}}, [x_labels] {[auto] {x_label}, [step] {x_label, x_label_rate}}, tag, color) = native axis_1d(plane, center, pos_x_axis, normal, tag, color, x, x_unit, x_min, x_max, x_tick_step, x_labels, {"\[", x_label, "\]"}, x_label_rate)

/* ABSTRACT: Generates a two-dimensional axis mesh with ticks, labels, and units along the X and Y axes on a specified plane. */
/* PARAMETER[center]: A 3-vector indicating the center coordinates of the axis */
/* PARAMETER[pos_x_axis]: A 3-vector indicating the direction of the positive X-axis */
/* PARAMETER[pos_y_axis]: A 3-vector indicating the direction of the positive Y-axis */
/* PARAMETER[tag]: A vector of numbers used as the axis's tag */
/* PARAMETER[color]: A 4-vector representing the color for rendering the axis */
/* PARAMETER[x_unit]: Unit for the X-axis */
/* PARAMETER[x_rad]: Radius of the X-axis */
/* PARAMETER[x_min]: Minimum value for the X-axis (should be <= 0) */
/* PARAMETER[x_max]: Maximum value for the X-axis (should be >= 0) */
/* PARAMETER[x_tick_step]: Step size for ticks on the X-axis (measured in axis coordinates) */
/* PARAMETER[x_label]: A textual label for the X-axis (displayed next to the end of the positive X-axis) */
/* PARAMETER[x_label_rate]: Rate for displaying X-axis labels (numeric label assigned every `x_label_rate` ticks) */
/* PARAMETER[y_unit]: Unit for the Y-axis */
/* PARAMETER[y_rad]: Radius of the Y-axis */
/* PARAMETER[y_min]: Minimum value for the Y-axis (should be <= 0) */
/* PARAMETER[y_max]: Maximum value for the Y-axis (should be >= 0) */
/* PARAMETER[y_tick_step]: Step size for ticks on the Y-axis (measured in axis coordinates) */
/* PARAMETER[y_label]: A textual label for the Y-axis (displayed next to the end of the positive Y-axis) */
/* PARAMETER[y_label_rate]: Rate for displaying Y-axis labels (numeric label assigned every `y_label_rate` ticks) */
/* PARAMETER[off]: Specifies to keep the grid off (and instead display ticks) */
/* PARAMETER[on]: Specifies to keep the grid on (and not display ticks) */
/* RETURN: A mesh-tree according to the specified specifications */
func Axis2d([plane] {[main] {center}, [plane] {center, pos_x_axis, pos_y_axis}}, [x] {[main] {x_unit, x_rad}, [interval] {x_unit, x_min, x_max}, [step] {x_unit, x_min, x_max, x_tick_step}}, [x_labels] {[auto] {x_label}, [step] {x_label, x_label_rate}}, [y] {[main] {y_unit, y_rad}, [interval] {y_unit, y_min, y_max}, [step] {y_unit, y_min, y_max, y_tick_step}}, [y_labels] {[auto] {y_label}, [step] {y_label, y_label_rate}}, [grid] {[off] {}, [on]{}}, tag, color) = native axis_2d(plane, center, pos_x_axis, pos_y_axis, tag, color, grid, x, x_unit, x_min, x_max, x_tick_step, x_labels, {"\[", x_label, "\]"}, x_label_rate, y, y_unit, y_min, y_max, y_tick_step, y_labels, {"\[", y_label, "\]"}, y_label_rate)

/* ABSTRACT: Generates a three-dimensional axis mesh with ticks, labels, and units along the X, Y, and Z axes on a specified plane. */
/* REMARK: In my opninion, using a left handed coordinate system looks better in 3D than a right handed one, so I generally recommend setting the pos_y_axis to be `{0,-1,0}` */
/* PARAMETER[center]: A 3-vector indicating the center coordinates of the axis */
/* PARAMETER[pos_x_axis]: A 3-vector indicating the direction of the positive X-axis */
/* PARAMETER[pos_y_axis]: A 3-vector indicating the direction of the positive Y-axis */
/* PARAMETER[pos_z_axis]: A 3-vector indicating the direction of the positive Z-axis */
/* PARAMETER[tag]: A vector of numbers used as the axis's tag */
/* PARAMETER[color]: A 4-vector representing the color for rendering the axis */
/* PARAMETER[x_unit]: Unit for the X-axis */
/* PARAMETER[x_rad]: Radius of the X-axis */
/* PARAMETER[x_min]: Minimum value for the X-axis (should be <= 0) */
/* PARAMETER[x_max]: Maximum value for the X-axis (should be >= 0) */
/* PARAMETER[x_tick_step]: Step size for ticks on the X-axis (measured in axis coordinates) */
/* PARAMETER[x_label]: A textual label for the X-axis (displayed next to the end of the positive X-axis) */
/* PARAMETER[x_label_rate]: Rate for displaying X-axis labels (numeric label assigned every `x_label_rate` ticks) */
/* PARAMETER[y_unit]: Unit for the Y-axis */
/* PARAMETER[y_rad]: Radius of the Y-axis */
/* PARAMETER[y_min]: Minimum value for the Y-axis (should be <= 0) */
/* PARAMETER[y_max]: Maximum value for the Y-axis (should be >= 0) */
/* PARAMETER[y_tick_step]: Step size for ticks on the Y-axis (measured in axis coordinates) */
/* PARAMETER[y_label]: A textual label for the Y-axis (displayed next to the end of the positive Y-axis) */
/* PARAMETER[y_label_rate]: Rate for displaying Y-axis labels (numeric label assigned every `y_label_rate` ticks) */
/* PARAMETER[z_unit]: Unit for the Z-axis */
/* PARAMETER[z_rad]: Radius of the Z-axis */
/* PARAMETER[z_min]: Minimum value for the Z-axis (should be <= 0) */
/* PARAMETER[z_max]: Maximum value for the Z-axis (should be >= 0) */
/* PARAMETER[z_tick_step]: Step size for ticks on the Z-axis (measured in axis coordinates) */
/* PARAMETER[z_label]: A textual label for the Z-axis (displayed next to the end of the positive Z-axis) */
/* PARAMETER[z_label_rate]: Rate for displaying Z-axis labels (numeric label assigned every `z_label_rate` ticks) */
/* PARAMETER[off]: Specifies to keep the grid off (and instead display ticks) */
/* PARAMETER[on]: Specifies to keep the grid on (and not display ticks) */
/* RETURN: A mesh-tree according to the specified specifications */
func Axis3d([plane] {[main] {center}, [plane] {center, pos_x_axis, pos_y_axis, pos_z_axis}}, [x] {[main] {x_unit, x_rad}, [interval] {x_unit, x_min, x_max}, [step] {x_unit, x_min, x_max, x_tick_step}}, [x_labels] {[auto] {x_label}, [step] {x_label, x_label_rate}}, [y] {[main] {y_unit, y_rad}, [interval] {y_unit, y_min, y_max}, [step] {y_unit, y_min, y_max, y_tick_step}}, [y_labels] {[auto] {y_label}, [step] {y_label, y_label_rate}}, [z] {[main] {z_unit, z_rad}, [interval] {z_unit, z_min, z_max}, [step] {z_unit, z_min, z_max, z_tick_step}}, [z_labels] {[auto] {z_label}, [step] {z_label, z_label_rate}}, [grid] {[off] {}, [on] {}}, tag, color) = native axis_3d(plane, center, pos_x_axis, pos_y_axis, pos_z_axis, tag, color, grid, x, x_unit, x_min, x_max, x_tick_step, x_labels, {"\[", x_label, "\]"}, x_label_rate, y, y_unit, y_min, y_max, y_tick_step, y_labels, {"\[", y_label, "\]"}, y_label_rate, z, z_unit, z_min, z_max, z_tick_step, z_labels, {"\[", z_label, "\]"}, z_label_rate)

/* NOT_IMPLEMENTED_YET: */
func PolarAxis([plane] {[main] {center}, [normal] {center, normal}}, [horizontal] {[main] {x_rad}, [interval] {x_min, x_max}, [step] {x_min, x_max, x_tick_step, x_label_step}}, [vertical] {[main] {y_rad}, [interval] {y_min, y_max}, [step] {y_min, y_max, y_tick_step, y_label_step}}) = native not_implemented_yet(0)

/* ABSTRACT: Generates a parametric function mesh based on specified parameters. */
/* REMARK: You might want to refer to @REF[EmbedInSpace] for help on getting a function to placed in an axis */
/* PARAMETER[start]: The start value of the domain for the function (scalar) */
/* PARAMETER[stop]: The stop value of the domain for the function (scalar) */
/* PARAMETER[samples]: The number of samples within the domain for the function */
/* PARAMETER[f(u)]: The function f(u) that defines the parametric function. u is the input variable. The output should be a 3-vector */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, a white stroke with clear dots */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[dot]: A 4-vector representing the color for dots */
/* RETURN: Generates a mesh-tree according to the specified function and domain */
func ParametricFunc([domain] {[main] {start, stop}, [step] {start, stop, samples}}, f(u), tag, [color] {[default] {}, [stroke] {stroke}, [dotted] {stroke, dot}}) = native parametric_func(domain, start, stop, samples, f!, tag, color, stroke, dot)

/* ABSTRACT: Generates an explicit function mesh based on specified parameters. Note that this is a 1D explicit function. */
/* REMARK: You might want to refer to @REF[EmbedInSpace] for help on getting a function to placed in an axis */
/* PARAMETER[start]: The start value of the domain for the function */
/* PARAMETER[stop]: The stop value of the domain for the function */
/* PARAMETER[samples]: The number of samples within the domain for the function */
/* PARAMETER[f(x)]: The function f(x) that defines the explicit function. x is the input variable. The output should be a scalar. */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[default]: An enum branch specifying the default coloring scheme, white with clear dots */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[dot]: A 4-vector representing the color for dots */
/* RETURN: Generates a mesh-tree according to the specified function and domain */
func ExplicitFunc([domain] {[main] {start, stop}, [step] {start, stop, samples}}, f(x), tag, [color] {[default] {}, [stroke] {stroke}, [dotted] {stroke, dot}}) = identity:
	func g(u) = {u, f(u), 0}
	element: native parametric_func(domain, start, stop, samples, g!, tag, color, stroke, dot)

/* ABSTRACT: Generates a 2D explicit function mesh based on specified parameters. */
/* REMARK: I generally find it better to use @REF[ColorGrid] and @REF[PointMapped] to create explicit 2d functions. Its a bit more of a hassle, but you get more control on the overall coloring (and can technically do non rectangular domains). Also check out @REF[EmbedinSpace] for easy use of transforming from axes coordinates to global coordinates */
/* PARAMETER[x_min]: Minimum x-value for the function's domain */
/* PARAMETER[x_max]: Maximum x-value for the function's domain */
/* PARAMETER[y_min]: Minimum y-value for the function's domain */
/* PARAMETER[y_max]: Maximum y-value for the function's domain */
/* PARAMETER[x_step]: Step size for the x-coordinate */
/* PARAMETER[y_step]: Step size for the y-coordinate */
/* PARAMETER[f(x,y)]: The function f(x, y) that defines the 2D explicit function. The inputs are the x and y values, and the output is a scalar. */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill */
/* RETURN: Generates a 2D mesh representing the specified function over the given domain */
func ExplicitFunc2d([points] {[main] {x_min, x_max, y_min, y_max}, [step] {x_min, x_max, y_min, y_max, x_step, y_step}}, f(x,y), tag, stroke, fill) = identity:
	func col(pos) = fill
	func p(point) = {point[0], point[1], f(point[0], point[1])}
	var xs = 0
	var ys = 0
	if points == 0
		xs = (x_max - x_min) / 64
		ys = (y_max - y_min) / 64
	else
		xs = x_step
		ys = y_step
	let c = native color_grid(1, x_min, x_max, y_min, y_max, xs, ys, 0, tag, 1, col!, stroke)
	element: native mesh_glossy(0, native mesh_point_map(0, c, 0, p!), 0)

/* ABSTRACT: Generates a 2D implicit function mesh based on specified parameters. We use the marching squares algorithm. */
/* REMARK: In general, The granularity is not great and I do not recommend using this function in its current state */
/* PARAMETER[x_min]: Minimum x-value for the function's domain */
/* PARAMETER[x_max]: Maximum x-value for the function's domain */
/* PARAMETER[y_min]: Minimum y-value for the function's domain */
/* PARAMETER[y_max]: Maximum y-value for the function's domain */
/* PARAMETER[x_step]: Step size for the x-coordinate. This dictates the granularity in the x direction. */
/* PARAMETER[y_step]: Step size for the y-coordinate. This dictates the granularity in the y direction. */
/* PARAMETER[f(x,y)]: The function f(x, y) that defines the 2D implicit function. This should a return a scalar. The generated contour is going to be the boundary of the where this function is <= 0. This may be unexpected as in many cases this adds lines along the boundary of the rectangle (even if the function would not actually be approximately zero there). */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[color]: An enum branch specifying the coloring scheme */
/* PARAMETER[default]: An enum branch specifying to use the default coloring scheme, white stroke with no fill */
/* PARAMETER[stroke]: A 4-vector representing the color of the stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the fill. Note that this forces an uprank */
/* RETURN: Generates a 2D mesh representing the specified implicit function over the given domain */
func ImplicitFunc2d([points] {[main] {x_min, x_max, y_min, y_max}, [step] {x_min, x_max, y_min, y_max, x_step, y_step}}, f(x,y), tag, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native implicit_func_2d(points, x_min, x_max, y_min, y_max, x_step, y_step, f!, tag, color, stroke, fill)

/* ABSTRACT: Generates a difference plot of two explicit functions based on specified parameters. */
/* REMARK: Useful for showing the area (or signed area) under curves by setting g(x) to be 0 */
/* PARAMETER[start]: Starting value for the domain */
/* PARAMETER[stop]: Ending value for the domain */
/* PARAMETER[samples]: Number of samples within the domain */
/* PARAMETER[f(x)]: The first explicit function (should return a scalar) */
/* PARAMETER[g(x)]: The second explicit function (should return a scalar) */
/* PARAMETER[tag]: A vector of numbers used as the mesh's tag */
/* PARAMETER[pos_fill]: Color for the positive fill (where f(x) > g(x) */
/* PARAMETER[neg_fill]: Color for the negative fill (where f(x) < g(x) */
/* RETURN: Generates a difference plot of two explicit functions over the specified domain */
func ExplicitFuncDiff([domain] {[main] {start, stop}, [step] {start, stop, samples}}, f(x), g(x), tag, pos_fill, neg_fill) = native explicit_func_diff(domain, start, stop, samples, f!, g!, tag, pos_fill, neg_fill)

/* CATEGORY[6]: Mesh Operators */

/* ABSTRACT: Generates a bounding box around a mesh or a set of meshes based on specified parameters. Note that like @REF[WireFrame] and unlike most other operators, unselected meshes will not be included in the ouput */
/* PARAMETER[mesh]: The mesh-tree, the entirety of which will be used for this operation */
/* PARAMETER[root]: The root of the mesh-tree. This provides the container of all possible meshes we want to select from */
/* PARAMETER[tag_predicate(tag)]: For any given mesh in root, the user specifies whether or not the mesh should be included in the operation. The function is given the tag of the mesh in consideration. If a non-zero value is returned, the mesh is included; otherwise, it is skipped */
/* PARAMETER[tag]: A vector of numbers used as the bounding box's tag */
/* PARAMETER[default_buff]: the bounding box is put around the specified mesh, with some default amount of buffer in between */
/* PARAMETER[buffer]: A custom buffer size for the bounding box */
/* PARAMETER[default]: An enum branch specifying to use the default coloring scheme, white stroke with no fill */
/* PARAMETER[stroke]: A 4-vector representing the color of the bounding box's stroke */
/* PARAMETER[fill]: A 4-vector representing the color of the bounding box's fill */
/* RETURN: A mesh comprising the generated bounding box around the specified meshes (only the bounding box is returned)*/
func BoundingBox([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, tag, [buff] {[default_buff] {}, [custom] {buffer}}, [color] {[default] {}, [stroke] {stroke}, [solid] {stroke, fill}}) = native mesh_bounding_box(mesh_tree, mesh, tag_predicate!, buff, buffer, tag, color, stroke, fill)


/* ABSTRACT: The WireFrame operation generates a wireframe representation for the provided mesh-tree. Note that like @REF[BoundingBox] and unlike most other operators, the unselected meshes will not be included in the output. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be converted into wireframe representations. All provided meshes will be converted. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the wireframe conversion operation based on the provided tag. */
/* RETURN: A mesh comprising lines present at all original lines in the mesh, and more lines at the boundary of every single triangle. This is different behavior than a downrank. */
func WireFrame([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_wireframe(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: A rank of a mesh is said to be -1 if its empty, 0 if it only contains dots, 1 if it contains lines, and 2 if it contains triangles. The process of upranking is converting a mesh of rank n to rank n + 1. At this time, you can uprank a mesh if it is a loop mesh. That is, it containts a line (mesh of rank 1) that has an end back at its start. In such a case, the mesh will be upranked to rank 2, with triangles filling the interior of the section enclosed by the loop. */
/* IMPORTANT: You might not use uprank directly that much, but it's definitely important to know what rank is, what sort of meshes can be upranked, and how even if two meshes look identical on screen, they may have completely different topologies. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be upranked. All meshes provided will be upranked. */
/* PARAMETER[root]: The root of the mesh-tree, providing the container for meshes to select from */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the operation based on the tag provided. */
/* RETURN: As with many operator meshes, if you provided the full mesh set, then all meshes will be individually upranked, and the returned value is the mesh-tree comprising all of the upranked meshes. However, if you only choose a subset, then the returned value will consist of a mesh-tree of the upranked selected meshes. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no upranking*/
func Uprank([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_uprank(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: The downranking process involves converting a mesh of rank n to rank n - 1, by only include the boundary of that mesh (say a disk will be turned into a circle). This operation is applicable to meshes with higher ranks (lines or triangles) and reduces their complexity by downranking them to lower ranks (lines or dots, respectively). However, an empty mesh (rank -1) cannot be further downranked. */
/* IMPORTANT: Downranking can be useful to select only the border of a mesh. It's most often used to convert a planar mesh to its boundary. However, the most important part is knowing what it does, and how meshes with equal visual representations can have extremely different topologies. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be downranked. All provided meshes will undergo downranking. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the downranking operation based on the provided tag. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually downranked, and the return value is the mesh-tree of all the down ranked meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the downranked selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no downranking). */
func Downrank([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_downrank(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: The tesselation process involves subdividing a mesh into smaller parts or increasing its geometric complexity by recursive division, thereby producing a more detailed representation. This operation takes an existing mesh and generates a more refined version by dividing each triangle into smaller triangles. */
/* REMARK: Tesselation can be used when we want to apply a @REF[PointMapped], @REF[ColorMapped], or some other similar non linear operation, where if we place it on the existing mesh, the transformation would be too choppy. Tesselation only affects the triangles. If you have pure line meshes, then you might want to look at @REF[LineSubdivided] instead */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be tesselated. All provided meshes will undergo the tesselation process. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the tesselation operation based on the provided tag. */
/* PARAMETER[depth]: Specifies the level of subdivision or the depth of tesselation. A higher depth value indicates more subdivisions and increased mesh complexity. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually tesselated, and the return value is the mesh-tree of all the tesselated meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the tesselated selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no tesselation). */
func Tesselated([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, depth) = native mesh_subdivided(mesh_tree, mesh, tag_predicate!, depth)

/* ABSTRACT: The LineSubdivided operation involves replacing each line in a line mesh with some integer N lines. */
/* PARAMETER[mesh]: Represents the mesh-tree containing the line segments to be subdivided. All provided line meshes will undergo subdivision. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a line mesh should be included in the subdivision operation based on the provided tag. */
/* PARAMETER[factor]: Specifies the factor by which the line segments will be subdivided. Higher factor values indicate more subdivisions and increased line resolution. In particular, each line will be replaced by `factor` lines. */
/* RETURN: If the complete mesh set is provided, all line meshes will be individually subdivided, and the return value is the mesh-tree of all the subdivided meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the subdivided selected line meshes, while the unselected meshes will remain unchanged. Crucially, all line meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no subdivision). */
func LineSubdivided([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, factor) = native mesh_line_subdivided(mesh_tree, mesh, tag_predicate!, factor)

/* ABSTRACT: The Extruded operation involves creating a 3d body extending each mesh in the given mesh-tree along the direction specified by the delta vector. For instance, a rectangle could be transformed into a rectangular prism, or a circle could become a cylinder. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be extruded. All provided meshes will undergo the extrusion process. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the extrusion operation based on the provided tag. */
/* PARAMETER[delta]: Specifies the direction and length of the extrusion for each mesh. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually extruded, and the return value is the mesh-tree of all the extruded meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the extruded selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no extrusion). */
func Extruded([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, delta) = native mesh_extruded(mesh_tree, mesh, tag_predicate!, delta)

/* ABSTRACT: The Revolved operation involves creating a surface by rotating each line mesh in the given mesh-tree around an axis specified by the rotation vector. In particular, each provided mesh should only have lines (and possibly boundary dots)  */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be revolved. All provided meshes will undergo the revolution process. */
/* PARAMETER[root]: The rot of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the revolution operation based on the provided tag. */
/* PARAMETER[rotation]: Specifies the axis and angle of rotation for each mesh (radians). Should be a 3-vector */
/* RETURN: If the complete mesh set is provided, all meshes will be individually revolved, and the return value is the mesh-tree of all the revolved meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the revolved selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no revolution). */
func Revolved([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, rotation) = native mesh_revolved(mesh_tree, mesh, tag_predicate!, rotation)

/* ABSTRACT: The Redotted operation involves recoloring all dots in the mesh, leaving lines and triangles untouched. In particular, you can either apply a universal albedo, or apply a linear gradient. */
/* REMARK: Linear gradients in the recoloring process don't generally look that good (in particular, they might not actually appear all that linear. I am hoping to fix this process, but be aware of these issues in the meantime). */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes with dots to be recolored. All provided meshes' dots will undergo recoloring. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the recoloring operation based on the provided tag. */
/* PARAMETER[albedo]: A 4-vector that represents the albedo color for the dots. */
/* PARAMETER[start_color]: A 4-vector that represents the start color for the gradient, used when the gradient coloring is applied. */
/* PARAMETER[end_color]: A 4-vector that represents the end color for the gradient, used when the gradient coloring is applied. */
/* PARAMETER[start_vec]: A 3-vector that represents the start position for the gradient, used when the gradient coloring is applied. */
/* PARAMETER[end_vec]: A 3-vector that epresents the end position for the gradient, used when the gradient coloring is applied. */
/* RETURN: If the complete mesh set is provided, all meshes' dots will be individually recolored. The return value is the mesh-tree of all the recolored meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the recolored selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no recoloring). */
func Redotted([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, [color] {[albedo] {albedo}, [gradient] {start_color, end_color, start_vec, end_vec}}) = native mesh_recolored(mesh_tree, mesh, tag_predicate!, color, albedo, start_color, end_color, start_vec, end_vec, 0)

/* ABSTRACT: The Restroked operation involves recoloring all lines in the mesh, leaving dots and triangles untouched. You can apply either a universal albedo or a linear gradient to the lines. */
/* REMARK: Linear gradients in the recoloring process don't generally look that good (in particular, they might not actually appear all that linear. I am hoping to fix this process, but be aware of these issues in the meantime). */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes with lines to be recolored. All provided meshes' lines will undergo recoloring. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the recoloring operation based on the provided tag. */
/* PARAMETER[albedo]: A 4-vector representing the albedo color for the lines. */
/* PARAMETER[start_color]: A 4-vector representing the start color for the gradient, used when applying gradient coloring to the lines. */
/* PARAMETER[end_color]: A 4-vector representing the end color for the gradient, used when applying gradient coloring to the lines. */
/* PARAMETER[start_vec]: A 3-vector representing the start position for the gradient, used when applying gradient coloring to the lines. */
/* PARAMETER[end_vec]: A 3-vector representing the end position for the gradient, used when applying gradient coloring to the lines. */
/* RETURN: If the complete mesh set is provided, all meshes' lines will be individually recolored. The return value is the mesh-tree of all the recolored meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the recolored selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no recoloring). */
func Restroked([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, [color] {[albedo] {albedo}, [gradient] {start_color, end_color, start_vec, end_vec}}) = native mesh_recolored(mesh_tree, mesh, tag_predicate!, color, albedo, start_color, end_color, start_vec, end_vec, 1)

/* ABSTRACT: The Refilled operation involves recoloring all triangles in the mesh, leaving lines and dots untouched. It offers the choice between applying a universal albedo or a linear gradient to the triangles. */
/* REMARK: Linear gradients in the recoloring process don't generally look that good (in particular, they might not actually appear all that linear. I am hoping to fix this process, but be aware of these issues in the meantime). */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes with triangles to be recolored. All provided meshes' triangles will undergo recoloring. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the recoloring operation based on the provided tag. */
/* PARAMETER[albedo]: A 4-vector representing the albedo color for the triangles. */
/* PARAMETER[start_color]: A 4-vector representing the start color for the gradient, used when applying gradient coloring to the triangles. */
/* PARAMETER[end_color]: A 4-vector representing the end color for the gradient, used when applying gradient coloring to the triangles. */
/* PARAMETER[start_vec]: A 3-vector representing the start position for the gradient, used when applying gradient coloring to the triangles. */
/* PARAMETER[end_vec]: A 3-vector representing the end position for the gradient, used when applying gradient coloring to the triangles. */
/* RETURN: If the complete mesh set is provided, all meshes' triangles will be individually recolored. The return value is the mesh-tree of all the recolored meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the recolored selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no recoloring). */
func Refilled([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, [color] {[albedo] {albedo}, [gradient] {start_color, end_color, start_vec, end_vec}}) = native mesh_recolored(mesh_tree, mesh, tag_predicate!, color, albedo, start_color, end_color, start_vec, end_vec, 2)

/* ABSTRACT: The Retextured operation applies an image texture to all meshes within the provided mesh-tree. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be retextured. All meshes will undergo retexturing with the provided image. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the retexturing operation based on the provided tag. */
/* PARAMETER[image]: The image name used for texturing the meshes within the mesh-tree. See @REF[Image] for help on importing images. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually retextured with the specified image. The return value is the mesh-tree of all the retextured meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the retextured selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no retexturing). */
func Retextured([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, image) = native mesh_retextured(mesh_tree, mesh, tag_predicate!, image)

/* ABSTRACT: The Shifted operation translates or shifts all meshes within the provided mesh-tree by a specified displacement. */
/* IMPORTANT: Shifted is used often enough to be worth memorizing */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be shifted. All provided meshes will undergo translation by the specified delta. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the shifting operation based on the provided tag. */
/* PARAMETER[delta]: A 3-vector indicating the displacement by which the meshes will be shifted in 3D space. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually shifted by the specified delta. The return value is the mesh-tree of all the shifted meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the shifted selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no shifting). */
func Shifted([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, delta) = native mesh_shift(mesh_tree, mesh, tag_predicate!, delta)

/* ABSTRACT: The Scaled operation uniformly scales all meshes within the provided mesh-tree by a specified scale factor. Note that the scale is applied relative to the center. */
/* IMPORTANT: Scaled is used often enough to be worth memorizing */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be scaled. All provided meshes will undergo uniform scaling by the specified factor. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the scaling operation based on the provided tag. */
/* PARAMETER[scale]: Either a scalar value indicating the uniform scale factor to apply to all dimensions, or a 3-vector indiciating how much to scale in each dimension. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually scaled uniformly by the specified factor. The return value is the mesh-tree of all the scaled meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the scaled selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no scaling). */
func Scaled([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, scale) = native mesh_scale(mesh_tree, mesh, tag_predicate!, scale)

/* ABSTRACT: The Rotated operation applies a rotation transformation to all meshes within the provided mesh-tree. The rotation is appplied relative to the center of the mesh. */
/* IMPORTANT: Rotated is used often enough to be worth memorizing */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be rotated. All provided meshes will undergo the specified rotation. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the rotation operation based on the provided tag. */
/* PARAMETER[rotation]: Specifies the rotation transformation to be applied to the meshes. This should be a 3-vector, with the direction being the axis and the magnitude being the amount to turn in radians (using the right hand rule). */
/* RETURN: If the complete mesh set is provided, all meshes will be individually rotated as per the specified rotation. The return value is the mesh-tree of all the rotated meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the rotated selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no rotation). */
func Rotated([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, rotation) = native mesh_rotate(mesh_tree, mesh, tag_predicate!, rotation)

/* ABSTRACT: The Faded operation adjusts the opacity of meshes within the provided mesh-tree uniformly. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to adjust opacity. All provided meshes will have their opacity adjusted. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the opacity adjustment based on the provided tag. */
/* PARAMETER[opacity]: A scalar value indicating the opacity to apply uniformly to all meshes. The value ranges from 0 (fully transparent) to 1 (fully opaque). */
/* RETURN: If the complete mesh set is provided, all meshes will have their opacity adjusted. The return value is the mesh-tree of all the adjusted meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes with adjusted opacity, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no opacity adjustment). */
func Faded([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, opacity) = native mesh_faded(mesh_tree, mesh, tag_predicate!, opacity)

/* ABSTRACT: The WithZIndex operation sets the Z-index for meshes within the provided mesh-tree. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to apply Z-index. All provided meshes will have their Z-index set. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the Z-index setting based on the provided tag. */
/* PARAMETER[index]: A number value representing the Z-index to assign to the meshes. Lower values position the meshes closer to the background, while higher values position them closer to the foreground. */
/* RETURN: If the complete mesh set is provided, all meshes will have their Z-index set. The return value is the mesh-tree of all the meshes with updated Z-index. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes with updated Z-index, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. no Z-index assignment). */
func WithZIndex([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, index) = native mesh_zindex(mesh_tree, mesh, tag_predicate!, index)

/* ABSTRACT: The Projected operation maps meshes from 3D space onto another mesh by projecting each point onto another mesh along a given ray */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be projected. All provided meshes will undergo projection. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the projection based on the provided tag. */
/* PARAMETER[screen]: Represents the mesh-tree of the screen, dictating the entire screen*/
/* PARAMETER[screen_root]: The root of the mesh-tree of the screen, providing the container for screen selection. */
/* PARAMETER[screen_predicate(tag)]: Determines whether a mesh  should be included in the screen, based on the provided tag. */
/* PARAMETER[ray]: A ray (3-vector) in 3D space defining the direction for the projection. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually projected onto the 2D screen. The return value is the mesh-tree of all the projected meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the projected selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. not projected). */
func Projected([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, [screen_tree] {[root] {screen}, [tag_pred] {screen_root, screen_predicate(tag)}}, ray) = native mesh_project(mesh_tree, mesh, tag_predicate!, screen_tree, screen, screen_predicate!, ray)

/* ABSTRACT: The PointMapped operation maps points (of vertices) in a mesh-tree to new locations based on a provided point map function. This map is topology preserving in that the starting and ending meshes have the exact same topology. */
/* IMPORTANT: PointMapped is useful for creating parameteric surfaces (or explicit surfaces) and in general applying topological transformations */
/* PARAMETER[mesh]: Represents the mesh-tree containing points to be mapped. All provided meshes' points will undergo mapping. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the point mapping based on the provided tag. */
/* PARAMETER[point_map(point)]: A function that defines the mapping for each point. In particular, a 3-vector is given as input (representing a vertex of the mesh), and 3-vector is given as output. */
/* RETURN: If the complete mesh set is provided, all meshes' points will be individually mapped according to the specified point map function. The return value is the mesh-tree of all the mapped meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the mapped selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. not mapped). */
func PointMapped([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, point_map(point)) = native mesh_point_map(mesh_tree, mesh, tag_predicate!, point_map!)

/* ABSTRACT: The ColorMapped operation maps the positions of vertices in a mesh-tree to new colors based on a provided color map function. Note that it applies to lines, dots, and triangles */
/* IMPORTANT: ColorMapped isn't as useful as PointMapped, but is still something you should know about to help visualized certain functions, and possibly for debugging as well */
/* PARAMETER[mesh]: Represents the mesh-tree containing points with colors to be mapped. All provided meshes' point colors will undergo mapping. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the color mapping based on the provided tag. */
/* PARAMETER[color_map(point)]: A function that defines the mapping for each point's color. The function takes a vertex's position as input (3-vector) and returns a color value (4-vector). */
/* RETURN: If the complete mesh set is provided, all meshes' point colors will be individually mapped according to the specified color map function. The return value is the mesh-tree of all the mapped meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the mapped selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. not color mapped). */
func ColorMapped([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, color_map(point)) = native mesh_color_map(mesh_tree, mesh, tag_predicate!, color_map!)

/* ABSTRACT: The UVMapped operation maps the position of points in a mesh-tree to UV values based on a provided UV map function. */
/* PARAMETER[mesh]: Represents the mesh-tree containing points with UV coordinates to be mapped. All provided meshes' UV coordinates will undergo mapping. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the UV mapping based on the provided tag. */
/* PARAMETER[uv_map(point)]: A function that defines the mapping for each point's UV coordinates. The function takes a point's position as input (3-vector) and returns new UV values (2-vector). */
/* RETURN: If the complete mesh set is provided, all meshes' UV coordinates will be individually mapped according to the specified UV map function. The return value is the mesh-tree of all the mapped meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the mapped selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e. not UV mapped). */
func UVMapped([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, uv_map(point)) = native mesh_uv_map(mesh_tree, mesh, tag_predicate!, uv_map !)

/* ABSTRACT: The Retagged operation remaps the tags of meshes in a mesh-tree based on a provided function. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes with tags to be remapped. All provided meshes' tags will undergo remapping. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the retagging operation based on the provided tag. */
/* PARAMETER[retag(old_tag)]: A function that defines the remapping for each mesh's tag. The function takes an old tag value as input and returns a new tag value. */
/* RETURN: If the complete mesh set is provided, all meshes' tags will be individually remapped according to the specified retagging function. The return value is the mesh-tree of all the remapped meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the retagged selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided with their original tags (i.e., not retagged). */
func Retagged([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, retag(old_tag)) = native mesh_retagged(mesh_tree, mesh, tag_predicate!, retag!)

/* ABSTRACT: This function maps the selected meshes, with the tag given as an argument. This function may appear similar to @REF[Retagged], but is different in that we're mapping meshes instead of tags. It may be useful to apply a different transformation to different category of meshes. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be mapped. The selected meshes will undergo mapping based on the provided tag. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the mapping operation based on the provided tag. */
/* PARAMETER[tag_map(tag,mesh)]: A function that defines the mapping for each selected mesh based on its tag. The function takes a tag value and the mesh as inputs and applies a specific transformation to the mesh based on the tag. The output should be a mesh-tree. */
/* RETURN: If the complete mesh set is provided, all selected meshes will be individually mapped according to the specified tag map function. The return value is the mesh-tree of all the mapped meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the mapped selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e., not mapped). */
func TagMapped([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, tag_map(tag, mesh)) = native mesh_tag_map(mesh_tree, mesh, tag_predicate!, tag_map!)

/* ABSTRACT: The EmbedInSpace operation converts a mesh in axes space to world space */
/* IMPORTANT: While I think this function is still a bit verbose, it is still probably the easiest way to work with axes */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be positioned in 3D space. All provided meshes will be positioned accordingly. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in the positioning operation based on the provided tag. */
/* PARAMETER[axis_center]: A 3-vector indicating the center coordinates of the axes in the 3D space. */
/* PARAMETER[x_unit]: A scalar indicating what x value in axes space maps to 1 in world space */
/* PARAMETER[y_unit]: A scalar indicating what y value in axes space maps to 1 in world space */
/* PARAMETER[z_unit]: A scalar indicating what z value in axes space maps to 1 in world space */
/* RETURN: If the complete mesh set is provided, all meshes will be individually positioned according to the specified axes in the 3D space. The return value is the mesh-tree of all the positioned meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the positioned selected meshes, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e., not positioned). */
func EmbedInSpace([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, axis_center, x_unit, y_unit, z_unit) = native mesh_embed_in_space(mesh_tree, mesh, tag_predicate!, axis_center, x_unit, y_unit, z_unit)

/* NOT_IMPLEMENTED_YET: */
func VertexSet([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func FaceSet([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func TetrahedronSet([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func GaussianSurfaces([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func Loops([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native not_implemented_yet(0)

/* ABSTRACT: The AddedGloss operation adds a glossy effect to the provided meshes in the mesh-tree, suitable for 3d scenes. It doesn't look that good currently, but should hopefully look better in the future. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to which the glossy effect will be applied. All provided meshes will have glossiness added. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should have the glossy effect applied based on the provided tag. */
/* RETURN: If the complete mesh set is provided, all meshes will have the glossy effect added. The return value is the mesh-tree of all the meshes with added glossiness. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes with the glossy effect, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e., without the added glossy effect). */
func AddedGloss([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_glossy(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: The MovedToSide operation moves the provided meshes in the mesh-tree to a specified edge or corner on screen. NOTE: this function currently assumes that the camera is in the initial state. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be moved. All provided meshes will undergo the movement operation. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be moved based on the provided tag. */
/* PARAMETER[dir]: A 3D vector indicating the direction in which the meshes will be moved. If the x is positive, then it will be moved to the right side, if it's negative than the left. If the y is positive, then it will be moved to the top, and otherwise to the bottom. the z is currently unused. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually moved to the specified direction. The return value is the mesh-tree of all the moved meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes moved to the specified direction, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e., without being moved). */
func MovedToSide([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, dir) = native mesh_to_side(mesh_tree, mesh, tag_predicate!, dir)

/* ABSTRACT: The Centered operation repositions the provided meshes within the mesh-tree to a specified center point. In particular, the center of the selected meshes will be moved to the target location. */
/* IMPORTANT: This function is used often enough that it should be worth memorizing. Well, I think positioning in Monocurl isn't great right now so different people may have different ideas of what is the best way to position, so just explore the different options and choose one that works best. Definitely, however, try not to always specify the positions manually as that's rather painful */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be repositioned. All provided meshes will undergo repositioning. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be repositioned based on the provided tag. */
/* PARAMETER[at]: A 3D vector indicating the new center point to which the meshes will be moved. */
/* RETURN: If the complete mesh set is provided, all meshes will be individually repositioned to the specified center point. The return value is the mesh-tree of all the repositioned meshes. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes repositioned to the specified center point, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but be provided as is (i.e., without being repositioned). */
func Centered([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, at) = native mesh_centered(mesh_tree, mesh, tag_predicate!, at)

/* ABSTRACT: The MatchedEdge operation aligns specified edges of meshes within the provided mesh-tree with a reference edge. Formally, we ensure that exists a plane that is normal to the direction such that it is tangent to both mesh sets, both meshes are on the same side of the plane, and that dot product between the direction and any vector from the mesh to any point on the plane is nonnegative. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes with edges to be aligned. All provided meshes' will undergo alignment. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be aligned based on the provided tag. */
/* PARAMETER[ref]: A reference mesh-tree, to which the target mesh tree will be aligned to */
/* PARAMETER[dir]: A direction vector indicating the alignment direction. */
/* RETURN: If the complete mesh set is provided, all selected meshes' edges will be aligned with the reference mesh based on the specified direction. The return value is the mesh-tree of all meshes with aligned edges. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes with aligned edges, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but their edges will remain unaligned. */
func MatchedEdge([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, ref, dir) = native mesh_matched_edge(mesh_tree, mesh, tag_predicate!, ref, dir)

/* ABSTRACT: The MovedNextTo operation relocates meshes within the provided mesh-tree next to a reference mesh based on the specified direction. Formally, we move the mesh such that the difference of their centers is a scalar multiple of the specified direction. Moreover, there exists a plane normal to the provided direction that separates the mesh from the reference mesh (and in fact, a small buffer will be added). Finally, the dot product between the direction and any vector from a point on the reference mesh to a point on the plane is positive. */
/* PARAMETER[mesh]: Represents the mesh-tree containing meshes to be relocated. All provided meshes will undergo relocation. */
/* PARAMETER[root]: The root of the mesh-tree, serving as the container for mesh selection. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be moved based on the provided tag. */
/* PARAMETER[ref]: A reference mesh-tree, to which the target mesh tree will be moved next to. */
/* PARAMETER[dir]: A direction vector indicating the relocation direction. */
/* RETURN: If the complete mesh set is provided, all selected meshes will be moved next to the reference mesh based on the specified direction. The return value is the mesh-tree of all meshes after relocation. However, if only a subset is chosen, the returned value will comprise a mesh-tree of the selected meshes after relocation, while the unselected meshes will remain unchanged. Crucially, all meshes you didn't select will still be included in the result mesh_tree, but their positions will remain unchanged. */
func MovedNextTo([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, ref, dir) = native mesh_next_to(mesh_tree, mesh, tag_predicate!, ref, dir)

/* NOT_IMPLEMENTED_YET: */
func Masked(mesh, mask) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func Joined(mesh, additional) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func SetDifference(mesh, subtraction) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func SymmetricDifference(mesh, subtraction) = native not_implemented_yet(0)

/* NOT_IMPLEMENTED_YET: */
func MinkowkskiSum(mesh, adder) = native not_implemented_yet(0)

/* ABSTRACT: The XStack is an alias for a @REF[Stack] in the x direction. */
/* PARAMETER[mesh_vector]: the vector of mesh-trees to be stacked. */
/* PARAMETER[center]: Specifies to align meshes by their centers */
/* PARAMETER[align_dir]: An optional parameter specifying a custom alignment direction. */
/* PARAMETER[spacing]: A scalar value indicating the spacing between stacked meshes. */
/* RETURN: Stacks the provided meshes in the X direction, with an optional alignment direection. The return value is the resulting stacked formation of meshes, which itself is a mesh-tree */
func XStack(mesh_vector, [align] {[center] {}, [custom] {align_dir}}) = native mesh_stack(mesh_vector, {1,0,0}, align, align_dir, 0.1)

/* ABSTRACT: The YStack is an alias for a @REF[Stack] in the Y direction. */
/* PARAMETER[mesh_vector]: the vector of mesh-trees to be stacked. */
/* PARAMETER[center]: Specifies to align meshes by their centers */
/* PARAMETER[align_dir]: An optional parameter specifying a custom alignment direction. */
/* PARAMETER[spacing]: A scalar value indicating the spacing between stacked meshes. */
/* RETURN: Stacks the provided meshes in the Y direction, with an optional alignment direection. The return value is the resulting stacked formation of meshes, which itself is a mesh-tree */
func YStack(mesh_vector, [align] {[center] {}, [custom] {align_dir}}) = native mesh_stack(mesh_vector, {0,1,0}, align, align_dir, 0.1)

/* ABSTRACT: The ZStack is an alias for a @REF[Stack] in the Z direction. */
/* PARAMETER[mesh_vector]: the vector of mesh-trees to be stacked. */
/* PARAMETER[center]: Specifies to align meshes by their centers */
/* PARAMETER[align_dir]: An optional parameter specifying a custom alignment direction. */
/* PARAMETER[spacing]: A scalar value indicating the spacing between stacked meshes. */
/* RETURN: Stacks the provided meshes in the Z direction, with an optional alignment direection. The return value is the resulting stacked formation of meshes, which itself is a mesh-tree */
func ZStack(mesh_vector, [align] {[center] {}, [custom] {align_dir}}) = native mesh_stack(mesh_vector, {0,0,1}, align, align_dir, 0.1)

/* ABSTRACT: The Stack operation arranges meshes in the specified direction to create a stacked formation. The centers are along a line that is parallel to the direction by default, but this can be adjusted to be along some direction. The align direction should be normal to the main direction. There is a hyperplane normal to the direction that separates each adjacent pair of meshes, with some buffer */
/* IMPORTANT: You'll probably use @REF[XStack] and @REF[YStack] more, but if you understand the semantics of stack properly, then that should be good enough. Stacks are useful for quickly positioning meshes.  */
/* PARAMETER[mesh_vector]: the vector of mesh-trees to be stacked. */
/* PARAMETER[dir]: A direction vector indicating the stacking direction. */
/* PARAMETER[center]: Specifies to align meshes by their centers */
/* PARAMETER[align_dir]: An optional parameter specifying a custom alignment direction. */
/* PARAMETER[spacing]: A scalar value indicating the spacing between stacked meshes. */
/* RETURN: Stacks the provided meshes in the specified direction, with an optional alignment direection. The return value is the resulting stacked formation of meshes, which itself is a mesh-tree */
func Stack(mesh_vector, dir, [align] {[center] {}, [custom] {align_dir}}) = native mesh_stack(mesh_vector, dir, align, align_dir, 0.1)

/* ABSTRACT: The Grid function positions a set of meshes along a grid. */
/* PARAMETER[mesh_array]: a vector of vector of mesh-trees (row major). All subvectors need not be of the same length, however the number of generated columns is equal to longest subvector, and the number of columns is the number of such subvectors. Each mesh-tree is placed in its appropriate location in the grid, and the width of each column is the maximum over all such mesh-trees in the column, and similary for heights of a row. There is a small buffer that is added automatically. */
/* RETURN: Generates a grid pattern by arranging the provided meshes in a grid formation. The return value is the resulting grid mesh. */
func Grid(mesh_array) = native mesh_grid(mesh_array)

/* ABSTRACT: The Table function positions a set of meshes along a grid, and then adds a line border to each cell. */
/* PARAMETER[mesh_array]: a vector of vector of mesh-trees (row major). All subvectors need not be of the same length, however the number of generated columns is equal to longest subvector, and the number of columns is the number of such subvectors. Each mesh-tree is placed in its appropriate location in the grid, and the width of each column is the maximum over all such mesh-trees in the column, and similary for heights of a row. There is a small buffer that is added automatically. */
/* PARAMETER[stroke_tag]: the tag to be given to the added strokes. */
/* PARAMETER[default]: an enum branch specifying to use the default coloring scheme, which is a white stroke with no dot colors */
/* PARAMETER[stroke]: a 4-vector representing the color of the stroke */
/* RETURN: a mesh-tree that contains both the rearranged meshes and the border lines */
func Table(mesh_array, stroke_tag, [stroke_color] {[default] {}, [stroke] {stroke}}) = native mesh_table(mesh_array, stroke_tag, stroke_color, stroke, WHITE)

/* CATEGORY[9]: Mesh Utilities */

/* ABSTRACT: The mesh_transform function interpolates between two mesh trees using a specified interpolation factor. */
/* PARAMETER[src_tree]: Represents the source mesh tree. */
/* PARAMETER[dst_tree]: Represents the destination mesh tree. */
/* PARAMETER[t]: A scalar value between 0 and 1, indicating the interpolation factor. A value of 0 corresponds to the source mesh, while 1 corresponds to the destination mesh. */
/* RETURN: Interpolates between the source and destination mesh trees based on the provided interpolation factor 't'. The resulting mesh tree is a blend between the two input trees according to the specified factor. */
func mesh_transform(src_tree, dst_tree, t) = native mesh_lerp(src_tree, dst_tree, t)

/* ABSTRACT: The mesh_bend function interpolates between two mesh trees using a specified interpolation factor. Importantly, this bend can only be done between line meshes. It has the property that the interpolation is length preserving. That is, the length of the interpolated mesh is linearly interpolated. This makes it better suited for interpolating between a line and a circle for example. */
/* PARAMETER[src_tree]: Represents the source mesh tree. */
/* PARAMETER[dst_tree]: Represents the destination mesh tree. */
/* PARAMETER[t]: A scalar value between 0 and 1, indicating the interpolation factor. A value of 0 corresponds to the source mesh, while 1 corresponds to the destination mesh. */
/* RETURN: Interpolates between the source and destination mesh trees based on the provided interpolation factor 't'. The resulting mesh tree is a blend between the two input trees according to the specified factor. */
func mesh_bend(src_tree, dst_tree, t) = native mesh_bend(src_tree, dst_tree, t)

/* ABSTRACT: The mesh_sample function gets the point at some amount along the mesh. */
/* PARAMETER[mesh]: Represents the mesh to be sampled. NOTE: this is not a mesh-tree but a mesh. Also, the mesh should have a single line contour. If the provided mesh is a loop, it's unspecified what corresponds to t = 0. If it's bounded by dots t = 0 corresponds to the start and t = 1 corresponds to the end. */
/* PARAMETER[t]: A scalar value between 0 and 1, indicating the sampling factor. A value of 0 corresponds to the start of the mesh, while 1 corresponds to the end. Intermediate values sample points within the mesh according to the specified factor. */
/* RETURN: Samples the provided mesh at the specified interpolation factor 't', returning the point (3-vector) at that sampled position within the mesh. */
func mesh_sample(mesh, t) = native mesh_sample(mesh, t)

/* ABSTRACT: The mesh_normal function retrieves the normal at a specific point along the mesh. */
/* PARAMETER[mesh]: Represents the mesh from which the normal will be obtained. NOTE: This function expects a single line contour within the mesh. If the provided mesh is a loop, it's unspecified where t = 0 corresponds to. If it's bounded by dots, t = 0 corresponds to the start, and t = 1 corresponds to the end. */
/* PARAMETER[t]: A scalar value between 0 and 1, indicating the sampling factor along the mesh. A value of 0 corresponds to the start of the mesh, while 1 corresponds to the end. Intermediate values retrieve normals within the mesh based on the specified factor. */
/* RETURN: Retrieves the normal vector (3-vector) at the specified interpolation factor 't' along the provided mesh. */
func mesh_normal(mesh, t) = native mesh_normal(mesh, t)

/* ABSTRACT: The mesh_tangent function retrieves the tangent vector at a specified point along the mesh. */
/* PARAMETER[mesh]: Represents the mesh to be sampled. NOTE: This function operates on a single mesh, not a mesh-tree. The mesh should have a single line contour. If the provided mesh is a loop, it's unspecified what corresponds to t = 0. If it's bounded by dots, t = 0 corresponds to the start and t = 1 corresponds to the end. */
/* PARAMETER[t]: A scalar value between 0 and 1, indicating the sampling factor. A value of 0 corresponds to the start of the mesh, while 1 corresponds to the end. Intermediate values sample points within the mesh according to the specified factor. */
/* RETURN: Retrieves the tangent vector (3-vector) at the specified interpolation factor 't' along the provided mesh, returning the tangent vector at that sampled position within the mesh. */
func mesh_tangent(mesh, t) = native mesh_tangent(mesh, t)

/* ABSTRACT: Generates a vector of 3-vectors that specifies all vertices in the mesh. Note that there may be duplicates */
/* PARAMETER[mesh]: Specifies to take every single vertex of every single mesh in the mesh-tree */
/* PARAMETER[root]: Specifies the container of which meshes will be selected for in the operation */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh's vertices should be include  based on the provided tag. */
/* RETURN: a vector of 3-vectors representing all the vertices of the selected meshes*/
func mesh_vertex_set([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_vertex_set(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Generates a set of edges from the provided mesh-tree, each edge represented as a pair of vertices. */
/* PARAMETER[mesh]: Specifies to take every single edge of every single mesh in the mesh-tree */
/* PARAMETER[root]: Specifies the container that holds the meshes for the operation. */
/* PARAMETER[tag_predicate(tag)]: Determines whether edges from a mesh should be included based on the provided tag. */
/* RETURN: A set of edges extracted from the selected meshes, where each edge is represented by a pair of vertex indices. In particular, a vector of vector of 3-vector is return, where each subvector is of length 2 and represents an edge by its starting and ending vertices. The edges should be treated as undirected, and there may be duplicates. */
func mesh_edge_set([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_edge_set(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Generates a set of triangles from the provided mesh-tree, each triangle represented by its vertices. */
/* PARAMETER[mesh]: Specifies to take every single triangle of every single mesh in the mesh-tree */
/* PARAMETER[root]: Specifies the container that holds the meshes for the operation. */
/* PARAMETER[tag_predicate(tag)]: Determines whether triangles from a mesh should be included based on the provided tag. */
/* RETURN: A set of triangles extracted from the selected meshes (essentially the triangles that make up the faces of the mesh). The returned value is a vector of vector of 3-vectors, where each subvector represents a triangle by its 3 vertices. The order in which the vertices are provided is unspecified. There may be duplicates. */
func mesh_triangle_set([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_triangle_set(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Selects a subset of a mesh-tree. */
/* IMPORTANT: One of the more commonly used mesh utility functions. Also, note that this operation removes type information. For instance, suppose the input tree was a functor with type Circle. Then, the output will visually look the same as the original circle (assuming the predicate selects it), however, all type information will be lost. This means that we won't be able to do `x.center` or access any other attributes. This is especially important when trying to do operations related to Lerp, which relies on type information heavily. */
/* PARAMETER[root]: Specifies the mesh-tree of which we want to find a subset of. */
/* PARAMETER[tag_predicate(tag)]: Determines whether or not a mesh should be included in the output if it has the given tag*/
/* RETURN: A mesh-tree of all the selected meshes. It is guaranteed the output is a vector of meshes which has depth 1. */
func mesh_select([mesh_tree] {[main] {root, tag_predicate(tag)}}) = native mesh_select_tags(mesh_tree + 1, root, tag_predicate!)

/* ABSTRACT: Calculates the leftmost x coordinate of a mesh-tree. Note that this is not the same as using @REF[mesh_direction] with a left facing vector since that would be the negation of this. */
/* PARAMETER[mesh]: Specifies to consider every single mesh in the mesh-tree when finding the leftmost point */
/* PARAMETER[root]: Specifies the container mesh-tree of which we want to select meshes to consider in finding the leftmost point. */
/* PARAMETER[tag_predicate(tag)]: Determines whether or not a mesh should be included in the calculation of the leftmost point if it has the given tag*/
/* RETURN: the x coordinate of the left most point of the selected meshes */
func mesh_left([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_left(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Computes the rightmost x-coordinate of a mesh-tree. */
/* PARAMETER[mesh]: Takes into account every mesh within the mesh-tree when determining the rightmost x-coordinate. */
/* PARAMETER[root]: Indicates the container mesh-tree from which meshes are chosen to compute the rightmost point. */
/* PARAMETER[tag_predicate(tag)]: Decides whether a mesh with the given tag should contribute to finding the rightmost point. */
/* RETURN: The x-coordinate of the rightmost point among the selected meshes. */
func mesh_right([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_right(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Determines the topmost y-coordinate of a mesh-tree. */
/* PARAMETER[mesh]: Considers all meshes within the mesh-tree to find the topmost y-coordinate. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are chosen to compute the topmost point. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the given tag contributes to finding the topmost point. */
/* RETURN: The y-coordinate of the topmost point among the selected meshes. */
func mesh_up([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_up(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Calculates the lowest y coordinate of a mesh-tree. This operation doesn't equate to using @REF[mesh_direction] with a downward-facing vector, as that would be the negative of this result. */
/* PARAMETER[mesh]: Specifies consideration of each mesh in the mesh-tree when determining the lowest point. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are selected for identifying the lowest point. */
/* PARAMETER[tag_predicate(tag)]: Determines whether a mesh should be included in computing the lowest point if it has the given tag. */
/* RETURN: The y coordinate of the lowest point among the selected meshes. */
func mesh_down([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_down(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Computes the forwardmost (highest z value, away from the csreen) z-coordinate of a mesh-tree. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree to determine the forwardmost z-coordinate. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are chosen to compute the forwardmost point. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh, upon having the given tag, should be included in computing the forwardmost point. */
/* RETURN: The z-coordinate of the forwardmost point among the selected meshes. */
func mesh_forward([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_forward(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Computes the backward-most z coordinate of a mesh-tree. Note that this operation differs from using @REF[mesh_direction] with a backward-facing vector, which would result in the negation of this value. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree to determine the backward-most z coordinate. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are chosen to compute the backward-most point. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh, upon having the given tag, should be included in computing the backward-most point. */
/* RETURN: The z coordinate of the backward-most point among the selected meshes. */
func mesh_backward([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = - native mesh_backward(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Calculates the extreme point in a given direction within a mesh-tree. More specifically, it calculates the dot product between that point and the given direction value. */
/* PARAMETER[mesh]: Includes all meshes within the mesh-tree in the direction calculation. */
/* PARAMETER[root]: Represents the container mesh-tree from which meshes are chosen for the direction calculation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the direction calculation. */
/* PARAMETER[direc]: A vector specifying the direction in which to find the extreme point. */
/* RETURN: Finds the dot product between the the most extreme point among the selected meshes and the direction (normalized). Thus, this function returns a scalar */
func mesh_direc([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, direc) = native mesh_direc(mesh_tree, mesh, tag_predicate!, direc)

/* ABSTRACT: Computes the width of the selected meshes within the provided mesh-tree. */
/* PARAMETER[mesh]: Includes all meshes within the mesh-tree in calculating the width. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are chosen for width calculation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the width calculation. */
/* RETURN: Computes the width of the selected meshes, which is the difference between the rightmost and leftmost x-coordinates. */
func mesh_width([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_right(mesh_tree, mesh, tag_predicate!) - native mesh_left(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Computes the height of the selected meshes within the provided mesh-tree. */
/* PARAMETER[mesh]: Includes all meshes within the mesh-tree in calculating the height. */
/* PARAMETER[root]: Specifies the container mesh-tree from which meshes are chosen for height calculation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the height calculation. */
/* RETURN: Computes the height of the selected meshes, which is the difference between the topmost and bottommost y-coordinates. */
func mesh_height([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_up(mesh_tree, mesh, tag_predicate!) - native mesh_down(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Determines the rank of the selected meshes within the provided mesh-tree. See @REF[Uprank] for a discussion about rank. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for ranking. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for ranking. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the ranking. */
/* RETURN: Retrieves the maximum rank among the selected meshes. The ranks are -1 for empty meshes, 0 for dot-only meshes, 1 for line meshes, and 2 for triangle meshes. */
func mesh_rank([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_rank(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Computes the center of the selected meshes within the given mesh-tree. We calculate the center by finding the axis-aligned bounding box, and then finding the center of that bounding box. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for center computation. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for center calculation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the center calculation. */
/* RETURN: Retrieves the center point of the selected meshes in the provided mesh-tree. */
func mesh_center([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_center(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Casts a ray from a source point along a specified direction to check for intersections with the selected meshes within the provided mesh-tree. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for raycasting. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for raycasting. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag participates in the raycasting process. */
/* PARAMETER[src]: The source point from which the ray originates, a 3-vector. */
/* PARAMETER[direction]: The direction of the ray, a 3-vector. */
/* RETURN: Returns -1 if the ray does not interst the selected meshes, and otherwise gives the amount of distance a ray would have to travel from the source point to hit the selected meshes */
func mesh_raycast([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, src, direction) = native mesh_raycast(mesh_tree, mesh, tag_predicate!, src, direction)

/* ABSTRACT: Checks if a point lies withinthe selected meshes within the provided mesh-tree. */
/* REMARK: This functional performs relatively poorly and may be inaccurate since it's hard to get right with epsilon checking */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for containment check. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for containment check. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag is included in the containment check. */
/* PARAMETER[point]: The point to check for containment within the selected meshes. */
/* RETURN: Returns 1 or 0 indicating if the point lies within the selected meshes within the provided mesh-tree. */
func mesh_contains([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, point) = native mesh_contains(mesh_tree, mesh, tag_predicate!, point)

/* ABSTRACT: Computes the minimum distance between a test point and the selected meshes within the provided mesh-tree. NOTE: this is purely between the points that are a part of the mesh. This means that in a sphere, for example, there would actually be positive distance between a test point in the center and the sphere. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for distance computation. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for distance calculation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the distance computation. */
/* PARAMETER[test_point]: The point (3-vector) for which the minimum distance from the selected meshes is calculated. */
/* RETURN: The minimum distance between the test point and the selected meshes within the provided mesh-tree. */
func mesh_dist([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}, test_point) = native mesh_dist(mesh_tree, mesh, tag_predicate!, test_point)

/* ABSTRACT: Counts the number of contours in the selected meshes within the provided mesh-tree. A contour is somewhat technical to define, but essentially its a subset of mesh that is connected (the exception is when we have contours that happen to intersect but are unrelated, however this is typically an edge case and not often observed). For instance, a circle has one contour. An annulus that is not upranked has two contours since you cannot get from the inner ring to the outer ring. However, an upranked annulus has a single contour since all components of the mesh are reachable from one another.  A mesh may not have a contour in the case that it is an empty mesh, but otherwise it contains at least one contour. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree for counting contours. */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for contour counting. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh with the provided tag contributes to the contour count. */
/* RETURN: The count of contours present in the selected meshes within the provided mesh-tree. */
func mesh_contour_count([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_contour_count(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: Separates the meshes of a mesh-tree into its constiuent contours. See @REF[mesh_contour_count] for a more detailed description. */
/* PARAMETER[mesh]: Considers all meshes in the mesh-tree separating contours */
/* PARAMETER[root]: Specifies the container mesh-tree where meshes are selected for contour separation. */
/* PARAMETER[tag_predicate(tag)]: Determines if a mesh should be included in the result */
/* RETURN: A flat vector which contains the seprated contour */
func mesh_contour_separate([mesh_tree] {[full] {mesh}, [tag_pred] {root, tag_predicate(tag)}}) = native mesh_contour_separated(mesh_tree, mesh, tag_predicate!)

/* ABSTRACT: For a given set of iterators, this method returns their followers */
/* IMPORTANT: This function is not commonly used, but is necessary if you want to create some custom animations */
/* PARAMETER[iterators&]: the iterators in question */
/* RETURN: the followers of the given iterator */
func followers(iterators&) = identity:
	element: native read_followers(iterators)

/* CATEGORY[10]: Core Animations */

/* ABSTRACT: The base functor for all animations. It is not recommended you use this functor directly */
/* PARAMETER[pull&]: a variable-tree, that can be used to keep track of state. By convention, pull is used for variables we want to write to throughout the animation */
/* PARAMETER[push&]: a variable-tree, that can be used to keep track of state. By convention, push is used for variables we want to read from throuhgout the animation */
/* PARAMETER[sentinel(t,dt,pull&,push&)]: the function that is called each frame with the current time, the changei n time, and references to the user provided pull and push variables. The function should do whatever it wants with the state, and then return 0 to indicate the animation is not finished, 1 if the animation must be finished immediately, or -1 if the animation can exit, but should continue if animations that are in parallel with it are still running */
/* RETURN: an animation that obeys the specified behavior. Note that the animation is not run immediately when it is created. */
func Anim(pull&, push&, sentinel(t, dt, pull&, push&)) = native animation(pull, push, sentinel!)

/* ABSTRACT: A Wait animation does nothing for the specified amount of seconds, and then ends. */
/* IMPORTANT: Waiting is crucial in getting animation timing right. It helps add emphasis, spacing to scenes, and also time for voice-overs (though I generally recommend freeze-frames in the editor as an easier method) */
/* PARAMETER[time]: the amount of time to wait. Should be non-negative */
/* RETURN: an animation that when run, will wait for the specified time period */
func Wait(time) = Anim:
	pull&: {}
	push&: {}
	sentinel(t, dt, pull&, push&): t >= time

/* ABSTRACT: An animation that transfer the entirety of the from variable to the into variable. If into is empty, then type information is preserved. Otherwise, it is lost. Also, to make semantics clear, we required that the into variable be in line with its follower (that is, there cannot be any changes to the into variable since its last Set). This is easy to fix by simply calling Set: on the into variable right before this animation if you need to */
/* IMPORTANT: Transfer is important for denoting ownership. It's also good for moving variables into auxiliary trees for temporary purposes */
/* PARAMETER[from&]: The sources of the animation. Note that from can be a variable tree */
/* PARAMETER[into&]: The destination of the animation. Note that into CANNOT be a variable tree, it must be a single variable */
/* RETURN: An animation the executes the transfer. The from iterators and followers are all the empty vector, whereas whereas the into iterators and followers are going to be iterator original content + the transferred content */
func Transfer(from&, into&) = Anim:
	let expected_hash = native mesh_hash(0, native read_followers(from), 0)
	let region = native transfer(into, 0, from, 0, 0)
	native set_followers({from, into})
	pull&: into
	push&: from
	sentinel(t, dt, pull&, push&): native transfer_runtime(pull, 0, push, 0, 0, region, expected_hash)
	
/* ABSTRACT: An animation that transfer the a subset of the from variable to the into variable. In this case, type information is always lost, even if the selection is the entirey of the from variable. Also, to make semantics clear, we required that the into variable be in line with its follower (that is, there cannot be any changes to the into variable since its last Set). This is easy to fix by simply calling Set: on the into variable right before this animation if you need to */
/* IMPORTANT: TransferSubset is important for denoting ownership. It's also good for moving variables into auxiliary trees for temporary purposes. This is especially helpful when you want two animations on the same variable in parallel, so you use TransferSubset to split the variable into two auxiliary ones, perform animations on each half, and then transfer the contents back to the main variable. */
/* PARAMETER[from&]: The sources of the animation. Note that from can be a variable tree */
/* PARAMETER[tag_predicate(tag)]: This specifies the subset of the from variable that should be transferred over to the target into variable.
/* PARAMETER[into&]: The destination of the animation. Note that into CANNOT be a variable tree, it must be a single variable */
/* RETURN: An animation the executes the transfer. The from iterators and followers are all the unselected portions, whereas the into iterators and followers are going to be iterator original content + the transferred content. For all variables, type information is elided. */
func TransferSubset([subset] {[main] {from&, tag_predicate(tag)}}, into&) = Anim:
	/* conceptually
	/* 1) get hash of creation follower */
	/* 2) perform transfer */
	/* 3) update creation follower */
	/* runtime */
	/* 1) delete the regions of the from variable, ensuring same hash as follower */
	/* 2) insert the iterator value into into& */
	/* that's it */
	let expected_hash = native mesh_hash(1, native read_followers(from), tag_predicate!)
	let region = native transfer(into, 1, from, tag_predicate!, 0)
	native set_followers({from, into})
	pull&: into
	push&: from
	sentinel(t, dt, pull&, push&): native transfer_runtime(pull, 1, push, tag_predicate!, 0, region, expected_hash)

/* ABSTRACT: An animation that copies the entirety of the from variable to the into variable. If into is empty, then type information is preserved. Otherwise, it is lost. However, do note that the from variables are not modified at all during this process (as it is a copy). Also, to make semantics clear, we required that the into variable be in line with its follower (that is, there cannot be any changes to the into variable since its last Set). This is easy to fix by simply calling Set: on the into variable right before this animation if you need to. */
/* PARAMETER[from&]: The sources of the animation. Note that from can be a variable tree */
/* PARAMETER[into&]: The destination of the animation. Note that into CANNOT be a variable tree, it must be a single variable */
/* RETURN: An animation the executes the copy. The from iterators and followers are all unaffected, whereas the into iterators and followers are going to be iterator original content + the transferred content */
func Copy(from&, into&) = Anim:
	let expected_hash = native mesh_hash(0, native read_followers(from), 0)
	let region = native transfer(into, 0, from, 0, 1)
	native set_followers(into)
	pull&: into
	push&: from
	sentinel(t, dt, pull&, push&): native transfer_runtime(pull, 0, push, 0, 1, region, expected_hash)
	
/* ABSTRACT: An animation that copies a subset of the from variable to the into variable. Type information is always lost in the copy (even if you select the entirey of the from variable). However, do note that the from variables are not modified at all during this process (as it is a copy. Also, to make semantics clear, we required that the into variable be in line with its follower (that is, there cannot be any changes to the into variable since its last Set). This is easy to fix by simply calling Set: on the into variable right before this animation if you need to. */
/* PARAMETER[from&]: The sources of the animation. Note that from can be a variable tree */
/* PARAMETER[tag_predicate(tag)]: This specifies the subset of the from variable that should be transferred over to the target into variable.
/* PARAMETER[into&]: The destination of the animation. Note that into CANNOT be a variable tree, it must be a single variable */
/* RETURN: An animation the executes the copy. The from iterators and followers are all unaffected, whereas the into iterators and followers are going to be iterator original content + the transferred content */
func CopySubset([subset] {[main] {from&, tag_predicate(tag)}}, into&) = Anim:
	let expected_hash = native mesh_hash(1, native read_followers(from), tag_predicate!)
	let region = native transfer(into, 1, from, tag_predicate!, 1)
	native set_followers(into)
	pull&: into
	push&: from
	sentinel(t, dt, pull&, push&): native transfer_runtime(pull, 1, push, tag_predicate!, 1, region, expected_hash)

/* ABSTRACT: This is an animation operator that takes a bunch of animations and almost puts them all in parallel, but there is a small offset between consecutive animations */
/* PARAMETER[anims]: a vector of animation-trees */
/* PARAMETER[average_offset]: the average offset in seconds between consecutive animations */
/* PARAMETER[unit_map(u)]: slightly complicated, but essentially dictates how the offset of any given animation should vary. unit_map(u) should be monotonically non-decreasing and map the interval 0 to 1 onto 0 to 1 */
/* RETURN: an animation-tree according to the above specification */
func LaggedMap(anims, [offset_details] {[main] {average_offset}, [parameterized] {average_offset, unit_map(u)}}) = identity:
	var ret = {}
	var t = 0
	for a in anims
		var offset = average_offset * len(anims)
		if offset_details == 1
			offset = offset * unit_map(t)
		else
			offset = offset * smooth(t)
		ret += sticky {Wait(offset), a}
		t += 1 / len(anims)
	element: ret

/* CATEGORY[11]: Follower Animations */

/* ABSTRACT: This is a follower animation that instaneously sets the follower to the current value of the iterator */
/* IMPORTANT: Set is a commonly used follower */
/* PARAMETER[vars&]: A variable-tree that lists all iterators that should have their followers set. Scene variables such as background or camera are allowed */
/* RETURN: An animation that will instaneously update all the followers of the iterator to the current iterator value */
func Set(vars&) = Anim:
	let capture = vars
	native set_followers(vars)
	pull&: vars
	push&: {}
	sentinel(t, dt, pull&, push&): native set(pull, capture)
 
/* ABSTRACT: This is a follower animation. For all meshes present in the iterator but not in the follower, a grow animation will be applied. For all meshes present in the follower but not in the iterator, a shrink animation will be applied. After the animation, the corresponding followers are set to the value of the iterator. */
/* PARAMETER[meshes&]: A variable-tree corresponding to iterators that the animation should apply to (no scene variables are allowed) */
/* PARAMETER[time]: the amount of seconds that the animation should take */
/* PARAMETER[unit_map(u)]: defaults to smooth(u). If provided, it is essentially a rate function that controls the timing of this animation. It is given the normalized time from 0 to 1 and should spit out a normalized time from 0 to 1. */
/* RETURN: Returns an animation that, when executed, will grow in the insertions and shrink the deletions */
func Grow(meshes&, [config] {[main] {time}, [parameterized] {time, unit_map(u)}}) = identity:
	func _Grow(mesh&) = identity:
		var ret = {}
		tree constant = {}
		tree insert = {}
		tree delete = {}

		let org = mesh
		let triple = native showhide_decomp(native read_followers(mesh), mesh)
	
		ret += Transfer:
			from&: mesh
			into&: constant
		
		ret += Set:
			{insert, delete, constant} = triple
			vars&: {insert, delete, constant}
  
		ret += Anim:
			pull&: insert
			push&: {}
			sentinel(t, dt, pull&, push&): native grow(pull, triple[0], t, config, time, unit_map!, 0)
		
		ret += sticky Anim:
			pull&: delete
			push&: {}
			sentinel(t, dt, pull&, push&): native grow(pull, triple[1], t, config, time, unit_map!, 1)
	   
		ret += Set:
			constant = org
			insert = delete = {}
			vars&: {constant, insert, delete}
			
		ret += Transfer:
			from&: constant
			into&: mesh
			
		element: ret
	var ret = {}
	ret += reference_map:
		vars&: meshes
		action(leaf&): sticky _Grow:
			mesh&: leaf
	element: ret

/* ABSTRACT: This is a follower animation. For all meshes present in the iterator but not in the follower, a fade in animation will be applied. For all meshes present in the follower but not in the iterator, a fade out animation will be applied. After the animation, the corresponding followers are set to the value of the iterator. */
/* PARAMETER[meshes&]: A variable-tree corresponding to iterators that the animation should apply to (no scene variables are allowed) */
/* PARAMETER[time]: the amount of seconds that the animation should take */
/* PARAMETER[unit_map(u)]: defaults to smooth(u). If provided, it is essentially a rate function that controls the timing of this animation. It is given the normalized time from 0 to 1 and should spit out a normalized time from 0 to 1. */
/* PARAMETER[delta]: defaults to the zero vector. If provided, it is the delta position that meshes will  translate throughout the animation. */
/* RETURN: Returns an animation that, when executed, will fades in the insertions and fades out the deletions */
func Fade(meshes&, [config] {[main] {time}, [parameterized] {time, unit_map(u), delta}}) = identity:
	func _FadeIn(mesh&) = identity:
		var ret = {}
		tree constant = {}
		tree insert = {}
		tree delete = {}

		let org = mesh
		let triple = native showhide_decomp(native read_followers(mesh), mesh)
	
		ret += Transfer:
			from&: mesh
			into&: constant
		
		ret += Set:
			{insert, delete, constant} = triple
			vars&: {insert, delete, constant}
  
		ret += Anim:
			pull&: insert
			push&: {}
			sentinel(t, dt, pull&, push&): native fade(pull, triple[0], t, config, time, unit_map!, 0, delta)
		
		ret += sticky Anim:
			pull&: delete
			push&: {}
			sentinel(t, dt, pull&, push&): native fade(pull, triple[1], t, config, time, unit_map!, 1, delta)
	   
		ret += Set:
			constant = org
			insert = delete = {}
			vars&: {constant, insert, delete}
			
		ret += Transfer:
			from&: constant
			into&: mesh
		element: ret
	var ret = {}
	ret += reference_map:
		vars&: meshes
		action(leaf&): sticky _FadeIn:
			mesh&: leaf
		
	element: ret

/* ABSTRACT: This is a follower animation. For all meshes present in the iterator but not in the follower, a write  animation will be applied. For all meshes present in the follower but not in the iterator, an unwrite animation will be applied. After the animation, the corresponding followers are set to the value of the iterator. Note that you can do this animation on any mesh, not just text-like meshes. */
/* PARAMETER[meshes&]: A variable-tree corresponding to iterators that the animation should apply to (no scene variables are allowed) */
/* PARAMETER[time]: the amount of seconds that the animation should take */
/* PARAMETER[unit_map(u)]: defaults to smooth(u). If provided, it is essentially a rate function that controls the timing of this animation. It is given the normalized time from 0 to 1 and should spit out a normalized time from 0 to 1. */
/* RETURN: Returns an animation that, when executed, will write the insertions and unwrite the deletions */
func Write(meshes&, [config] {[main] {time}, [parameterized] {time, unit_map(u)}}) = identity:
	func _Write(mesh&) = identity:
		var ret = {}
		tree constant = {}
		tree insert = {}
		tree delete = {}

		let org = mesh
		let triple = native showhide_decomp(native read_followers(mesh), mesh)
		let true_ins = native mesh_contour_separated(0, triple[0], 0)
		let true_del = native mesh_contour_separated(0, triple[1], 0)
	
		ret += Transfer:
			from&: mesh
			into&: constant
		
		ret += Set:
			{insert, delete, constant} = {true_ins, true_del, triple[2]}
			vars&: {insert, delete, constant}
  
		ret += Anim:
			pull&: insert
			push&: {}
			sentinel(t, dt, pull&, push&): native write(pull, true_ins, t, config, time, unit_map!, 0)
		
		ret += sticky Anim:
			pull&: delete
			push&: {}
			sentinel(t, dt, pull&, push&): native write(pull, true_del, t, config, time, unit_map!, 1)
	   
		ret += Set:
			constant = org
			insert = delete = {}
			vars&: {constant, insert, delete}
			
		ret += Transfer:
			from&: constant
			into&: mesh
			
		element: ret
	var ret = {}
	ret += reference_map:
		vars&: meshes
		action(leaf&): sticky _Write:
			mesh&: leaf
		
	element: ret


/* ABSTRACT: A follower animation that linearly interpolates followers between towards the iterator.  NOTE: It is required that when Lerp is run, the follower and iterator should be of the same functor type (say Circle and Circle). Otherwise, Monocurl does not know how to interpolate the fields. EXTRA NOTE: this is even the case if visually both the follower and iterator look like circles, but they come from different types (i.e. Monocurl does not how to interpolate a RegularPolygon with high n-value and a Circle. Likewise if type information is ever removed because you use an operation such as @REF[mesh_select], you cannot interpolate from a Circle to a pure-mesh, even if the pure-mesh originally came from a Circle. Again, this is because once type information is lost, Monocurl does not know which fields it should be interpolating. */
/* REMARK: It is recommended you read the documentation for @REF[lerp] to get an understaning of the exact rules of linear interpolation.  */
/* IMPORTANT: Lerp is one of the most useful follower animations and at the core of Monocurl. */
/* PARAMETER[vars&]: A variable tree of iterators that specify which variables the animation should be applied to. Scene variables such as background or camera are allowed */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* RETURN: An animation that, when executed, will lerp the corresponding followers from their initial follower state to the iterator state. After the animation, the followers are set to the values of the iterators.  */
func Lerp(vars&, [config] {[main] {time}, [parameterized] {time, unit_map(u)}}) = identity:
	func _Lerp(leaf&) = identity:
		var ret = {}
		tree aux = {}
		let start = native read_followers(leaf)
		let end = leaf
		let is_scene = native is_scene_variable(leaf)
		
		if is_scene
			ret += Anim:
				pull&: leaf
				push&: {}
				sentinel(t, dt, pull&, push&): native lerp_anim(pull, start, end, t, config, time, unit_map!)
			
			ret += Set:
				leaf = end
				vars&: leaf
		else
			ret += Transfer:
				from&: leaf
				into&: aux
			
			ret += Anim:
				pull&: aux
				push&: {}
				sentinel(t, dt, pull&, push&): native lerp_anim(pull, start, end, t, config, time, unit_map!)
			
			ret += Set:
				aux = end
				vars&: aux

			ret += Transfer:
				from&: aux
				into&: leaf
		
		element: ret
	var ret = {}
	ret += reference_map:
		vars&: vars
		action(leaf&): sticky _Lerp:
			leaf&: leaf
	element: ret

/* ABSTRACT: A follower animation that smoothly interpolates the camera variable from its follower state to its iterator state, avoiding gimbal lock. After the animation, the camera follower is set to the camera iterator */
/* PARAMETER[camera&]: The scene camera variable*/
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* RETURN: An animation that lerps the camera in a manner avoiding gimbal lock */
func CameraLerp(camera&, [config] {[main] {time}, [parameterized] {time, unit_map(u)}}) = identity:
	let start = native read_followers(camera)
	let end = camera
	let alpha = native arccos(dot(start[2], end[2]))
	let sin_a = native sin(alpha)
	func slerp(a, b, t) = identity:
		var ret = 0
		if native abs(sin_a) < 0.00001
			ret = vec_add(vec_mul(1 - t, a), vec_mul(t, b))
		else
			ret = vec_add(vec_mul(native sin(alpha * (1 - t)) / sin_a, a), vec_mul(native sin(alpha * t) / sin_a, b))
		element: ret
	func aux(t) = {lerp(start[0], end[0], t), lerp(start[1], end[1], t), slerp(start[2], end[2], t), lerp(start[3], end[3], t), lerp(start[4], end[4], t)}
	let true_start = aux:
		t: 0
	let true_end = aux:
		t: 1

	var ret = {}
	ret += Set:
		camera = true_start
		vars&: camera
	if config != 0
		ret += Lerp:
			camera = true_end
			vars&: camera
			time: time
			unit_map(u): unit_map(u)
	else
		ret += Lerp:
			camera = true_end
			vars&: camera
			time: time
	ret += Set:
		camera = end
		vars&: camera
	element: ret

/* ABSTRACT: A follower animation that interpolates between the follower and iterator based only on the points of the meshes. That is, no type information is necessary */
/* IMPORTANT: Transform is a very commonly used follower animation */
/* REMARK: Transform is generally useful when you need to transform between unrelated obejcts (e.g. square to circle) where lerp wouldn't be applicable. It's typically somewhat faster than lerp as well */
/* REMARK: If you want to only transform a subset, take a look at @REF[TransformSubset] */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[meshes&]: The meshes that this animation will apply to */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* PARAMETER[path_arc]: Defaults to the zero vector. If provided, it should be a rotation vector whose magnitude is how much rotation should take place (i.e., how much deviation from a straight line), and the direction is the axis of rotation. See @REF[Arrow] for more information on how a path arc works */
/* RETURN: An animation that interpolates between the follower and iterator using point information alone. After the animation is executed, all followers are set to the value of their iterators. */
func Transform(meshes&, [config] {[main] {time}, [parameterized] {time, unit_map(u), path_arc}}) = identity:
	func _Trans(mesh&) = identity:
		tree aux = {}
		let start = native read_followers(mesh)
		let end = mesh
		let triple = native mesh_matched(start, end, 0, 0)
  
		var ret = {}
		ret += Transfer:
			from&: mesh
			into&: aux
			
		ret += Set:
			aux = triple[1]
			vars&: aux
	
		ret += Anim:
			pull&: aux
			push&: {}
			sentinel(t, dt, pull&, push&): native transform(triple[0], pull, triple[2], t, config, time, unit_map!, path_arc, 0)
				
		ret += Set:
			aux = end
			vars&: aux
		
		ret += Transfer:
			from&: aux
			into&: mesh
			
		element: ret
		
	var ret = {}
	ret += reference_map:
		vars&: meshes
		action(leaf&): sticky _Trans:
			mesh&: leaf
	
	element: ret
	
/* ABSTRACT: A follower animation that interpolates between the follower and iterator based only on the points of the meshes. That is, no type information is necessary. The difference between this and @REF[Transform] is that in TagTransform, the matching algorithm will match meshes in follower only with those in the iterator that have the same tags. This allows you to have more control over how the transformation looks. */
/* IMPORTANT: TagTransform is a very commonly used follower animation */
/* REMARK: If you want to only transform a subset, take a look at @REF[TagTransformSubset] */
/* PARAMETER[meshes&]: The meshes that this animation will apply to */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* PARAMETER[path_arc]: Defaults to the zero vector. If provided, it should be a rotation vector whose magnitude is how much rotation should take place (i.e., how much deviation from a straight line), and the direction is the axis of rotation. See @REF[Arrow] for more information on how a path arc works */
/* RETURN: An animation that interpolates between the follower and iterator using point information alone. After the animation is executed, all followers are set to the value of their iterators. */
func TagTransform(meshes&, [config] {[main] {time}, [parameterized] {time, unit_map(u), path_arc}}) = identity:
	func _Trans(mesh&) = identity:
		tree aux = {}
		let start = native read_followers(mesh)
		let end = mesh
		let triple = native mesh_matched(start, end, 1, 0)
  
		var ret = {}
		ret += Transfer:
			from&: mesh
			into&: aux
			
		ret += Set:
			aux = triple[1]
			vars&: aux
	
		ret += Anim:
			pull&: aux
			push&: {}
			sentinel(t, dt, pull&, push&): native transform(triple[0], pull, triple[2], t, config, time, unit_map!, path_arc, 0)
				
		ret += Set:
			aux = end
			vars&: aux
		
		ret += Transfer:
			from&: aux
			into&: mesh
			
		element: ret
		
	var ret = {}
	ret += reference_map:
		vars&: meshes
		action(leaf&): sticky _Trans:
			mesh&: leaf
	
	element: ret

/* CATEGORY[12]: Progressors Animations */
/* ABSTRACT: This is a progressor animation (that is, it modifies the input variable), that lerps a subset of a mesh-tree from a specified starting value to the ending value. After the animation is finished, the iterator and follower are set to this value (replacing the specified subset with the end variable) */
/* PARAMETER[mesh&]: A single iterator that specifies the variable this animation should apply to */
/* PARAMETER[tag_predicate(tag)]: The function that takes in a mesh's tag and dictates whether it should take place in the lerping process */
/* PARAMETER[start]: The starting value */
/* PARAMETER[end]: The ending value (must be of same type as the starting value */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* RETURN: An animation that interpolates the selection from the start to the end. After the animation is executed, the iterator and follower are both updated such that the specified selection is replaced with the end value. */
func LerpSubset([subset] {[main] {mesh&, tag_predicate(tag)}}, start, end, [config] {[main] {time}, [parameterized] {time, unit_map(u)}}) = identity:
	var ret = {}
	tree aux = {}
	ret += Transfer:
		from&: mesh
		tag_predicate(tag): tag_predicate(tag)
		into&: aux
		
	ret += Anim:
		pull&: aux
		push&: {}
		sentinel(t, dt, pull&, push&): native lerp_anim(pull, start, end, t, config, time, unit_map!)
			
	ret += Set:
		aux = end
		vars&: aux

	ret += Transfer:
		from&: aux
		into&: mesh
		
	element: ret

/* ABSTRACT: A progressor animation that interpolates a subset of the input variable into the target, based only the points of the starting and ending values. That is, no type information is necessary. After the animation is finished, the iterator and follower are set to the final value (replacing the specified subset of the iterator with the target variable). */
/* PARAMETER[mesh&]: A single iterator that specifies the variable this animation should apply to */
/* PARAMETER[tag_predicate(tag)]: The function that takes in a mesh's tag and dictates whether it should take place in the transformation process */
/* PARAMETER[target]: The target value of the selection */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* PARAMETER[path_arc]: Defaults to the zero vector. If provided, it should be a rotation vector whose magnitude is how much rotation should take place (i.e., how much deviation from a straight line), and the direction is the axis of rotation. See @REF[Arrow] for more information on how a path arc works */
/* RETURN: An animation that interpolates the selection of the iterator to the target using point information alone. After the animation is executed, all followers and iterators are set to the final value (the original iterator where the selection is replaced with target) */
func TransformSubset([mesh_tree] {[main] {mesh&, tag_predicate(tag)}}, target, [config] {[main] {time}, [parameterized] {time, unit_map(u), path_arc}}) = identity:
	tree aux = {}
	let start = native read_followers(mesh)
	let end = mesh
	let triple = native mesh_matched(start, end, 0, 0)

	var ret = {}
	ret += Transfer:
		from&: mesh
		tag_predicate(tag): tag_predicate(tag)
		into&: aux

	ret += Anim:
		pull&: aux
		push&: {}
		sentinel(t, dt, pull&, push&): native transform(triple[0], pull, triple[2], t, config, time, unit_map!, path_arc, 0)
			
	ret += Set:
		aux = end
		vars&: aux
	
	ret += Transfer:
		from&: aux
		into&: mesh
		
	element: ret

/* ABSTRACT: A progressor animation that interpolates a subset of the input variable into the target, based only the points of the starting and ending values. That is, no type information is necessary. After the animation is finished, the iterator and follower are set to the final value (replacing the specified subset of the iterator with the target variable). The difference between this and @REF[TransformSubset] is that in TagTransformSubset, the matching algorithm will match meshes in follower only with those in the iterator that have the same tags. This allows you to have more control over how the transformation looks. */
/* PARAMETER[mesh&]: A single iterator that specifies the variable this animation should apply to */
/* PARAMETER[tag_predicate(tag)]: The function that takes in a mesh's tag and dictates whether it should take place in the transformation process */
/* PARAMETER[target]: The target value of the selection */
/* PARAMETER[time]: the amount of seconds the lerp should take place over */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* PARAMETER[path_arc]: Defaults to the zero vector. If provided, it should be a rotation vector whose magnitude is how much rotation should take place (i.e., how much deviation from a straight line), and the direction is the axis of rotation. See @REF[Arrow] for more information on how a path arc works */
/* RETURN: An animation that interpolates the selection of the iterator to the target using point information alone. After the animation is executed, all followers and iterators are set to the final value (the original iterator where the selection is replaced with target) */
func TagTransformSubset([mesh_tree] {[main] {mesh&, tag_predicate(tag)}}, target, [config] {[main] {time}, [parameterized] {time, unit_map(u), path_arc}}) = identity:
	tree aux = {}
	let start = native read_followers(mesh)
	let end = mesh
	let triple = native mesh_matched(start, end, 1, 0)

	var ret = {}
	ret += Transfer:
		from&: mesh
		tag_predicate(tag): tag_predicate(tag)
		into&: aux

	ret += Anim:
		pull&: aux
		push&: {}
		sentinel(t, dt, pull&, push&): native transform(triple[0], pull, triple[2], t, config, time, unit_map!, path_arc, 0)
			
	ret += Set:
		aux = end
		vars&: aux
	
	ret += Transfer:
		from&: aux
		into&: mesh
		
	element: ret

/* CATEGORY[15]: Indication Animations */

/* ABSTRACT: The Highlight animation function emphasizes a subset of a mesh-tree of a variable over a specified duration, flashing the selected portion to a specified color. Note that highlight manages the trees for you; you do not need to provide a tree */
/* PARAMETER[value]: the mesh-tree that houses the meshes to be highlighted */
/* PARAMETER[tag_predicate(tag)]: The predicate function that determines whether a mesh that is part of the provided mesh-tree should undergo the flashing effect as a result of this animation. */
/* PARAMETER[color]: a 4-vector representing the color that the meshes should be flashed to */
/* PARAMETER[unit_map(u)]: Defaults to @REF[smooth](u). If provided, it is essentially a rate function that controls the timing of this animation. It receives normalized time from 0 to 1 and returns a normalized time from 0 to 1. */
/* PARAMETER[time]: How long the entire animation should take */
/* RETURN: Returns an animation that, when executed, produces a flashing effect for the specified subset of the variable's mesh-tree over the specified duration. */
func Highlight([mesh_tree] {[full] {value}, [tag_pred] {value, tag_predicate(tag)}}, [flash] {[main] {color}, [timed] {color, unit_map(u)}}, time) = identity:
	let capture = native mesh_select_tags(mesh_tree, value, tag_predicate!)
	tree aux = capture
	func _Highlight(mesh&) = Anim:
		pull&: mesh
		push&: {}
		sentinel(t, dt, pull&, push&): native highlight(pull, capture, t, flash, time, unit_map!, color)
	var ret = {}
	ret += Set:
		vars&: aux
	ret += _Highlight:
		mesh&: aux
	ret += Set:
		aux = {}
		vars&: aux
	element: ret

/* ABSTRACT: The Flash animation function flashes a subset of a mesh-tree of a variable, essentially making the mesh's lines written, and then unwritten some small time later  */
/* PARAMETER[value]: the mesh-tree that houses the meshes to be highlighted */
/* PARAMETER[tag_predicate(tag)]: The predicate function that determines whether a mesh that is part of the provided mesh-tree should undergo the flashing effect as a result of this animation. */
/* PARAMETER[time]: Specifies the duration of the flashing effect in seconds. */
/* PARAMETER[lead(u)]: given the normalized time, this function must specify a normalized time from 0 to 1 that dictates how far along the writing should be. lead(u) must be >= trail(u) for all u in 0 to 1 */
/* PARAMETER[trail(u)]: given the normalized time, this function must specify a normalized time from 0 to 1 that dictates how far along the unwriting should be. */
/* RETURN: Returns an animation that, when executed, flashes the specified subset of the variable's mesh-tree over the specified duration.  */
func Flash([mesh_tree] {[full] {value}, [tag_pred] {value, tag_predicate(tag)}}, [config] {[main] {time}, [parameterized] {time, lead(u), trail(u)}}) = identity:
	let capture = native mesh_select_tags(mesh_tree, value, tag_predicate!)
	tree aux = capture
	func _Flash(mesh&) = Anim:
		pull&: mesh
		push&: {}
		sentinel(t, dt, pull&, push&): native flash(pull, capture, t, config, time, lead!, trail!)
	var ret = {}
	ret += Set:
		vars&: aux
	ret += _Flash:
		mesh&: aux
	ret += Set:
		aux = {}
		vars&: aux
	element: ret
